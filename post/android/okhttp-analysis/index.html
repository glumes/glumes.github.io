<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">


  <title>开源库之 OkHttp 源码分析</title>
  <meta property="og:title" content="开源库之 OkHttp 源码分析" />
  <meta name="twitter:title" content="开源库之 OkHttp 源码分析" />

  <meta name="description" content="分析一波 OkHttp 的源码实现。">
  <meta property="og:description" content="分析一波 OkHttp 的源码实现。">
  <meta name="twitter:description" content="分析一波 OkHttp 的源码实现。">
  <meta name="author" content="Glumes"/>
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://glumes.com/post/android/okhttp-analysis/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="纸上浅谈" />

  <meta name="generator" content="Hugo 0.55.6" />
  <link rel="canonical" href="https://glumes.com/post/android/okhttp-analysis/" />
  <link rel="alternate" href="https://glumes.com/index.xml" type="application/rss+xml" title="纸上浅谈">
  <link rel="stylesheet" href="https://glumes.com/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://glumes.com/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://glumes.com/css/main.css?t=126" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://glumes.com/css/pygment_highlights.css" />
  <link rel="stylesheet" href="https://glumes.com/css/highlight.min.css" />
  <link rel="stylesheet" href="https://glumes.com/css/prism.css?t=123" />
  <link rel="stylesheet" href="https://glumes.com/css/search.css" />
  
  <link rel="stylesheet" href="https://glumes.com/css/reward.css" />
  

<link rel="stylesheet" href="https://res.cloudinary.com/glumes-com/raw/upload/v1516330613/website/css/prism.css" />






<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-84590324-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?9276c0ce2d3c49b591323abab4a32e1e";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
</script>



</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://glumes.com/">纸上浅谈</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">目录</a>
              <div class="navlinks-children">
                
                  <a href="/categories/android">Android</a>
                
                  <a href="/categories/opencv">opencv</a>
                
                  <a href="/categories/opengl">opengl</a>
                
                  <a href="/categories/%e9%9f%b3%e8%a7%86%e9%a2%91%e5%bc%80%e5%8f%91">ffmpeg</a>
                
                  <a href="/categories/python">python</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="生活" href="/categories/life">生活</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="文章集" href="/post/">文章集</a>
            </li>
          
        

        

        

        

      </ul>
    </div>

  </div>
</nav>





    
  
  
  




  
    <div id="header-big-imgs" data-num-img=1 data-img-src-1="https://image.glumes.com/images/2019/04/27/bc32fd77gy1fv5z250xs7j20zk0npjvg.jpg" ></div>
  

  <header class="header-section has-img">
    
      <div class="intro-header big-img">
        
        
        <div class="container">
          <div class="row">
              <div class="col-lg-12 col-md-12 col-md-offset-0">
                
                <div class="page-heading">
                
                  
                     <h1>开源库之 OkHttp 源码分析</h1>
                     
                    <span class="post-meta">
  Posted on September 11, 2018
  
</span>


                    
                  
                  
              </div>
            </div>
          </div>
        </div>
        <span class="img-desc" style="display: inline;"></span>
      </div>
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-12 col-md-12 col-md-offset-0">
            <div class="post-heading">
                <h1 align="center">开源库之 OkHttp 源码分析</h1>
                
                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">



        
      <div>
          
          
          <h5 id="tags" style="margin-top: 0px;">标签:
            
                <a href="https://glumes.com/tags/okhttp/">OkHttp</a> &nbsp;
            
          </h5>
          
      </div>

      <article role="main" class="blog-post" itemprop="articleBody" id="content">
        
        <p>分析一波 OkHttp 的源码实现。</p>

<h2 id="简单使用">简单使用</h2>

<p>官方给出了使用例子，具体详情参考 <a href="http://square.github.io/okhttp/">官网</a>。</p>

<pre><code class="language-java">// 创建 OkHttp 请求客户端
OkHttpClient client = new OkHttpClient();
// 构建一个请求
Request request = new Request.Builder()
      .url(url)
      .build();
// 执行网络请求并返回结果      
Response response = client.newCall(request).execute();      
// 得到结果内容
response.body().string();
</code></pre>

<p>可以看到，使用过程还是很容易理解的：</p>

<blockquote>
<p>首先创建请求客户端 -&gt; 接着创建网络请求 -&gt; 然后发出网络请求 -&gt; 最后得到请求结果。</p>
</blockquote>

<p>把网络请求过程抽象化之后就是上面的流水线步骤了，其中最重要的步骤就是发出网络请求了，在 OkHttp 中用到了责任链模式，对发出的网络请求会按照责任链表的顺序依次进行处理，比如请求重试、连接处理、缓存处理、日志处理等，这个地方再写一篇文章详细分析。</p>

<p>下面针对 OkHttp 的调用流程和结构作分析。</p>

<h2 id="创建请求">创建请求</h2>

<p>首先是创建请求客户端 OkHttpClient 和网络请求 Request 。</p>

<p>对于这种要创建某某对象的，上来就是一个建造者模式，建造者模式可以说是在开源项目中最常见的设计模式了。</p>

<p>在 OkHttpClient 和 Request 内部都有一个 <code>Builder</code> 的内部类用来执行具体的构建操作，一般 <code>Builder</code> 类有很多方法，它们都是用来设置具体构建参数的，顺着哪些方法就可以找到都有哪些配置选项，这些选项也就是对外暴露的接口，这算是阅读源码的一个小技巧了。</p>

<p>OkHttpClient 的 Builder 内部配置选项：</p>

<pre><code class="language-java">      dispatcher = new Dispatcher();
      // 使用默认的选项
      protocols = DEFAULT_PROTOCOLS;
      connectionSpecs = DEFAULT_CONNECTION_SPECS;
      eventListenerFactory = EventListener.factory(EventListener.NONE);
      proxySelector = ProxySelector.getDefault();
      cookieJar = CookieJar.NO_COOKIES;
      socketFactory = SocketFactory.getDefault();
      hostnameVerifier = OkHostnameVerifier.INSTANCE;
      certificatePinner = CertificatePinner.DEFAULT;
      proxyAuthenticator = Authenticator.NONE;
      authenticator = Authenticator.NONE;
      connectionPool = new ConnectionPool();
      dns = Dns.SYSTEM;
      followSslRedirects = true;
      followRedirects = true;
      retryOnConnectionFailure = true;
      connectTimeout = 10_000;
      readTimeout = 10_000;
      writeTimeout = 10_000;
      pingInterval = 0;
</code></pre>

<p>重点分析 <code>Dispatcher</code> 类用来管理和分发请求的，其他的如果没有指定的话都是默认选项，等用到时再具体分析。</p>

<p>在 Request 内部的 Builder 也有一些配置选项：</p>

<pre><code class="language-java">    HttpUrl url;
    String method;
    Headers.Builder headers;
    RequestBody body;
    /** A mutable map of tags, or an immutable empty map if we don't have any. */
    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();
</code></pre>

<p>像 <code>url</code>、<code>body</code>、<code>method</code> 这些都是 HTTP 请求相关的内容，用一个 <code>Request</code> 类将它们进行封装，到具体执行请求时，都会将它们取出来使用。</p>

<h2 id="同步执行">同步执行</h2>

<pre><code class="language-kotlin">val response = client.newCall(request).execute()
</code></pre>

<p>同步执行的代码如上，首先是 <code>newCall</code> 方法将 request 转换成 <code>RealCall</code> 对象，它实现了 <code>Call</code> 的接口。</p>

<p><code>Request</code> 类只是封装了请求的信息，比如 <code>GET</code>、<code>POST</code> 方法之类的，但具体的执行通过 <code>Call</code> 这一层来实现了。</p>

<pre><code class="language-java">  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    // Safely publish the Call instance to the EventListener.
    RealCall call = new RealCall(client, originalRequest, forWebSocket);
    call.eventListener = client.eventListenerFactory().create(call);
    return call;
  }
</code></pre>

<p>然后是 Call 的 <code>execute</code> 方法。</p>

<pre><code class="language-java">  @Override public Response execute() throws IOException {
    // 保证线程安全
    synchronized (this) {
      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
      executed = true;
    }
    captureCallStackTrace();
    eventListener.callStart(this);
    try {
      // 把请求添加到队列中
      client.dispatcher().executed(this);
      // 具体执行网络请求
      Response result = getResponseWithInterceptorChain();
      if (result == null) throw new IOException(&quot;Canceled&quot;);
      return result;
    } catch (IOException e) {
      // 请求失败的回调
      eventListener.callFailed(this, e);
      throw e;
    } finally {
      // 将请求从队列中移除
      client.dispatcher().finished(this);
    }
  }
</code></pre>

<p>首先是 <code>synchronized</code> 加锁保证线程安全，然后是通过 <code>Dispatcher</code> 类的 <code>executed</code> 方法将请求 <code>RealCall</code> 添加到请求的同步队列中去。</p>

<pre><code class="language-java">private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();

synchronized void executed(RealCall call) {
  runningSyncCalls.add(call);
}
</code></pre>

<p><code>runningSyncCalls</code> 是一个 <code>Deque</code> 类型的队列。<code>Deque</code> 是一个双端队列，它具有队列和栈的特性，队列中的元素可以从两端弹出，而插入和删除操作只能在队列的两端进行。</p>

<p><code>executed</code> 方法只是将请求添加到了队列中，具体的执行在 <code>getResponseWithInterceptorChain</code> 方法中，在这里就会将请求通过OkHttp 的各种拦截器，按照责任链模式进行调用，并得到请求返回的结果，用 <code>Response</code> 类封装。</p>

<p>当请求结束后，会调用 <code>Dispatcher</code> 类的 <code>finished</code> 方法。</p>

<pre><code class="language-java">  void finished(RealCall call) {
    finished(runningSyncCalls, call, false);
  }
  
  private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) {
    int runningCallsCount;
    Runnable idleCallback;
    synchronized (this) {
      // 将请求从队列中移除
      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn't in-flight!&quot;);
      if (promoteCalls) promoteCalls();
      runningCallsCount = runningCallsCount();
      idleCallback = this.idleCallback;
    }

    if (runningCallsCount == 0 &amp;&amp; idleCallback != null) {
      idleCallback.run();
    }
  }  
</code></pre>

<p><code>finished</code> 方法主要是将请求 <code>RealCall</code> 从队列中 <code>runningSyncCalls</code> 移除。</p>

<p>这里还有个小知识点就是 <code>try</code>、<code>catch</code>、<code>finally</code> 三者的执行顺序，在 <code>try</code> 语句里面执行了 <code>return</code> 语句，但是返回的结果会保存在一个临时区域里面，然后执行 <code>finally</code> 语句，移除队列请求后再继续返回。</p>

<h2 id="网络请求">网络请求</h2>

<p>下面重点看一下 <code>getResponseWithInterceptorChain</code> 方法。</p>

<pre><code class="language-java">  Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();
    interceptors.addAll(client.interceptors());
    // OkHttpClient 提供的默认拦截器
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());
    }
    interceptors.add(new CallServerInterceptor(forWebSocket));
    // 重点参数是 0 ，表示责任链的开始
    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
        originalRequest, this, eventListener, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());

    return chain.proceed(originalRequest);
  }
</code></pre>

<p>有一个拦截器 <code>Interceptor</code> 的集合，在创建 OkHttpClient 的时候可以通过 <code>Builder</code> 去添加我们自定义的拦截器，另外 OkHttp 也提供了几个默认的拦截器。</p>

<p>把拦截器添加到集合中，作为 <code>RealInterceptorChain</code> 类的参数，它实现了 <code>Chain</code> 接口，表示为一条<code>链</code>。在这条<code>链</code>上，每个拦截器都是它的一个节点，并且以链上任何一个拦截器为起点，又可以开始一条新的链。</p>

<p>具体来看看 <code>proceed</code> 方法：</p>

<pre><code class="language-java">  @Override public Response proceed(Request request) throws IOException {
    return proceed(request, streamAllocation, httpCodec, connection);
  }
  
  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
      RealConnection connection) throws IOException {
    if (index &gt;= interceptors.size()) throw new AssertionError();

    calls++;
    // 删除一些判断和抛出异常的方法
    
    // Call the next interceptor in the chain.
    // 以拦截器队列中的下一个拦截器为起点，构建新的请求链
    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
        writeTimeout);
    // 取出当前请求链中的第一个
    Interceptor interceptor = interceptors.get(index);
    // 执行当前拦截器的功能，并且开始子链的请求流程
    Response response = interceptor.intercept(next);

    // 删除一些判断和抛出异常的方法
    return response;
  }
</code></pre>

<p>整个拦截器的集合 <code>interceptors</code> 是不会变的，而 <code>index</code> 就对应从拦截器集合中取出拦截器的索引，为 0 表示取出第一个来作为整条 <code>链</code> 的起点，从而构建一条请求链。</p>

<p>当一个拦截器执行具体功能时，也就是 <code>intercept</code> 方法，会把下一个<code>链</code>作为参数传递过去，这样就又会以这条 <code>链</code> 为起始继续下一步的执行。</p>

<p>比如，看 <code>HttpLoggingInterceptor</code> 内部的实现:</p>

<pre><code class="language-java">    Request request = chain.request();
    if (level == Level.NONE) {
      return chain.proceed(request);
    }
</code></pre>

<p>如果要打印的日志即为为 <code>NONE</code>，也就是不打印，直接就开始 <code>链</code> 的下一个执行了。</p>

<p>简单地看，这里就是一个递归的调用流程。</p>

<h2 id="异步执行">异步执行</h2>

<pre><code class="language-kotlin">client.newCall(request).enqueue(object : okhttp3.Callback {

    override fun onFailure(call: okhttp3.Call?, e: IOException?) {
    }
    
    override fun onResponse(call: okhttp3.Call?, response: okhttp3.Response?) {
    }
})
</code></pre>

<p>异步请求的代码如上，和同步请求的区别在于后面是 <code>enqueue</code> 方法。</p>

<pre><code class="language-java">  @Override public void enqueue(Callback responseCallback) {
    synchronized (this) {
      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
      executed = true;
    }
    captureCallStackTrace();
    eventListener.callStart(this);
    // 通过 Dispatcher 管理请求
    // 
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
  }
</code></pre>

<p><code>enqueue</code> 需要传入一个 <code>Callback</code> 的回调接口，用来处理请求成功和失败。另外，在 <code>enqueue</code> 的内部还是通过 <code>Dispatcher</code> 进行请求的管理。</p>

<p>这里传入的参数是 <code>AsyncCall</code> 类，不再是 <code>RealCall</code> 类了，<code>AsyncCall</code> 类继承自 <code>NamedRunnable</code> 类，<code>NamedRunnable</code> 实现了 <code>Runnable</code> 接口。</p>

<p><code>NamedRunnable</code> 意思就是有名字的线程，会在线程执行时临时改变线程的名字，执行结束后再改回来。</p>

<pre><code class="language-java">  @Override public final void run() {
    // 保存当前线程的名字
    String oldName = Thread.currentThread().getName();
    // 设置新的名字
    Thread.currentThread().setName(name);
    try {
      execute();
    } finally {
      // 执行后再改为原来的名字
      Thread.currentThread().setName(oldName);
    }
  }
</code></pre>

<p>另外，<code>AsyncCall</code> 实现了 <code>NamedRunnable</code> 的抽象方法 <code>execute</code> ，该方法也是网络请求的具体执行部分，问题在于这些异步请求是如何分发和管理的，还是回到 <code>Dispatcher</code> 类中来。</p>

<pre><code class="language-java">  synchronized void enqueue(AsyncCall call) {
    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {
      runningAsyncCalls.add(call);
      executorService().execute(call);
    } else {
      readyAsyncCalls.add(call);
    }
  }
</code></pre>

<p>首先是判断异步请求队列 <code>runningAsyncCalls</code> 的个数是否超过最大请求数了，另外是判断同一主机的网络请求个数是否超过限制。</p>

<p>如果都不超过，就将请求添加到异步请求队列中，并在线程池中去执行。</p>

<p>如果超过了，就把请求添加到准备就绪的队列 <code>readyAsyncCalls</code> 中，等待后续再去执行。</p>

<p><code>executorService()</code> 方法的执行就是初始化线程池的。</p>

<pre><code class="language-java">  public synchronized ExecutorService executorService() {
    if (executorService == null) {
      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));
    }
    return executorService;
  }
</code></pre>

<p><code>ThreadPoolExecutor</code> 用来提供一个线程池，它的方法原型如下：</p>

<pre><code class="language-java">    public ThreadPoolExecutor(int corePoolSize,             // 核心线程池的大小
                              int maximumPoolSize,        // 线程池的最大大小
                              long keepAliveTime,         // 线程池空闲时，线程的存活时间
                              TimeUnit unit,             // 存活时间的时间单位
                              BlockingQueue&lt;Runnable&gt; workQueue, // 存放线程任务的队列
                              ThreadFactory threadFactory,      // 创建线程的工厂
                              RejectedExecutionHandler handler) {     // 任务拒绝策略
            // 省略
    }
</code></pre>

<p>使用线程池的好处是显而易见的，统一管理网络请求，减少线程频繁创建、销毁带来的开销。</p>

<p>通过线程池的 <code>execute</code> 方法去执行请求，具体就是 <code>Runnable</code> 接口中的 <code>run</code> 方法。</p>

<pre><code class="language-java">    // 异步请求中的方法
    @Override protected void execute() {
      boolean signalledCallback = false;
      try {
        // 具体执行的请求还是在这里
        Response response = getResponseWithInterceptorChain();
        if (retryAndFollowUpInterceptor.isCanceled()) {
          signalledCallback = true;
          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));
        } else {
          signalledCallback = true;
          responseCallback.onResponse(RealCall.this, response);
        }
      } catch (IOException e) {
        if (signalledCallback) {
          // Do not signal the callback twice!
          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);
        } else {
          // 请求失败的回调
          eventListener.callFailed(RealCall.this, e);
          responseCallback.onFailure(RealCall.this, e);
        }
      } finally {
        client.dispatcher().finished(this);
      }
    }
</code></pre>

<p>异步请求执行的线程变了，肯定就得有相应的回调通知，另外，具体是网络请求部分还是在 <code>getResponseWithInterceptorChain</code> 方法中。</p>

<p>在 <code>finally</code> 中还是会将异步的请求从队列中移除，不同的是内部最后一个参数为 false 。</p>

<pre><code class="language-java">  void finished(AsyncCall call) {
    // 与同步请求不同的是，最后一个参数为 True, 同步请求为 false
    finished(runningAsyncCalls, call, true);
  }
</code></pre>

<p>因为 <code>True</code>，所以 <code>promoteCalls</code> 就会执行。</p>

<pre><code class="language-java">  // 异步请求才会执行该方法
  private void promoteCalls() {
    // 优先把 readyAsyncCalls 队列中的请求执行完
    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.
    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.

    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
      AsyncCall call = i.next();

      if (runningCallsForHost(call) &lt; maxRequestsPerHost) {
        i.remove();
        runningAsyncCalls.add(call);
        executorService().execute(call);
      }

      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.
    }
  }
</code></pre>

<p>之前提到，如果异步请求队列已经满了，就会把请求放到准备就绪的队列 <code>readyAsyncCalls</code> 中去，那么 <code>promoteCalls</code> 方法就是来处理 <code>readyAsyncCalls</code> 队列中的请求的。</p>

<p>每次从队列中移除异步请求后 size 都会减一，然后再判断队列的数量是否还是超过了最大请求数量，如果是就返回，表示优先把异步队列中的请求消耗完，如果不是，表示有空位，那就从准备就绪的队列中取出请求来执行。</p>

<p>把 <code>readyAsyncCalls</code> 队列中的请求放到 <code>runningAsyncCalls</code> 队列中去，再通过线程池去执行，并且还是会判断 <code>runningAsyncCalls</code> 的数量是否超过了最大请求，超过了就返回，表示 OkHttp 中整个异步请求的数量不能超过 <code>maxRequests</code> 表示的数量。</p>

<p>就这样实现了 OkHttp 的异步请求管理流程，并且还有一个类似请求排队的机制，</p>

<h2 id="小结">小结</h2>

<p>OkHttp 是用来执行网络请求，包括同步和异步的请求。</p>

<p>对于同步请求，直接就执行了，同步阻塞直到返回取得请求结果。</p>

<p>对于异步请求，对请求进行管理，限制请求最大数量，如果超出数量就排队候选，每次执行完一次异步请求，有空位就去处理排队的请求。</p>

<p>对于具体的请求过程，通过责任链的模式，把请求分成多个过程，递归地对请求进行处理。</p>
        
          <div class="entry-shang text-center">
    <p>「真诚赞赏，手留余香」</p>
    <button class="zs show-zs btn btn-bred">赞赏</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
    <div class="zs-modal-head">
        <button type="button" class="close">×</button>
        <span class="author"><img src="/img/avatar.jpeg"/>Glumes</span>
        <p class="tip"><i></i><span>请我喝杯咖啡？</span></p>
    </div>
    <div class="zs-modal-body">
        <div class="zs-modal-btns">
            <button class="btn btn-blink" data-num="2">2元</button>
            <button class="btn btn-blink" data-num="5">5元</button>
            <button class="btn btn-blink" data-num="10">10元</button>
            <button class="btn btn-blink" data-num="50">50元</button>
            <button class="btn btn-blink" data-num="100">100元</button>
            <button class="btn btn-blink" data-num="1">任意金额</button>
        </div>
        <div class="zs-modal-pay">
            <button class="btn btn-bred" id="pay-text">2元</button>
            <p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
            <img src="/img/wechat-2.png" id="pay-image"/>
        </div>
    </div>
    <div class="zs-modal-footer">
        <span class="zs-wechat"><img src="/img/wechat-btn.png"/></span>
    </div>
</div>
        


                

                  <h4>欢迎扫码关注微信公众号：【音视频开发进阶】，获得最新文章推送~~~</h4>

                  <img src="https://ae01.alicdn.com/kf/U208b714bc7734ca99a743cf8c49a9b951.png">

                  <br/>

                


                

                原创文章，转载请注明来源: &nbsp;&nbsp; <a href="https://glumes.com/post/android/okhttp-analysis/">开源库之 OkHttp 源码分析</a>

                

                


        
        <div class="social-share" data-initialized="true" style="margin-bottom: 20px;margin-top:20px;">
    <center>
    <a href="#" class="social-share-icon icon-weibo"></a>
    <a href="#" class="social-share-icon icon-wechat"></a>
    <a href="#" class="social-share-icon icon-twitter"></a>
    <a href="#" class="social-share-icon icon-linkedin"></a>
    <a href="#" class="social-share-icon icon-facebook"></a>
    <a href="#" class="social-share-icon icon-qq"></a>
    <a href="#" class="social-share-icon icon-qzone"></a>
    </center>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        
      </article>

      
        

      

      
      <ul class="pager blog-pager">
        
          <li class="previous">
            <a href="https://glumes.com/post/opengl/opengl-glsl-3-mark/" data-toggle="tooltip" data-placement="top" title="OpenGL ES 3.0 着色器语言 GLSL 学习 Mark ">&larr; Previous Post</a>
          </li>
        
        
          <li class="next">
            <a href="https://glumes.com/post/android/cmake-best-practices/" data-toggle="tooltip" data-placement="top" title="Android NDK 开发之 CMake 必知必会">Next Post &rarr;</a>
          </li>
        
      </ul>
      

      
        
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "glumes" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        
      





    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">

          
          
          
              <li>
                <a href="mailto:zhaoying9402@outlook.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
              <li>
                <a href="https://github.com/glumes" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
              <li>
                <a href="https://weibo.com/u/3157458295" title="微博">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          
          <li>
            <a href="https://glumes.com/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="http://www.glumes.com">Glumes</a>
            
          

          &nbsp;&bull;&nbsp;
          2020

          
            &nbsp;&bull;&nbsp;
            <a href="https://glumes.com/">纸上浅谈</a>
            &nbsp;&bull;&nbsp;
            <a href="/sitemap.xml">网站地图</a>
          
        </p>


<div class="powered_by">
    <a href="http://www.miitbeian.gov.cn/">京ICP备15061219号-2</a>
    <br>
    <a href="https://zeuk.me">Designed by Zeuk,</a>
    <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
  </div>

        
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.55.6</a> powered &nbsp;&bull;&nbsp; Theme by <a href="https://github.com/rootsongjc/beautifulhugo">Beautiful Hugo</a> adapted to <a href="https://github.com/glumes/glumes.com">glumes-blog</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>


<script src="https://glumes.com/js/jquery-1.11.2.min.js"></script>
<script src="https://glumes.com/js/bootstrap.min.js"></script>
<script src="https://glumes.com/js/main.min.js"></script>
<script src="https://glumes.com/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script src="https://glumes.com/js/prism.js?t=123"></script>

<script src="https://glumes.com/js/reward.js"></script>





<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>







  





  </body>
</html>

