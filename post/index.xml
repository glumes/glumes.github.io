<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Glumes Blog</title>
    <link>https://glumes.com/post/</link>
    <description>Recent content in Posts on Glumes Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>zhaoying9402@gmail.com (Glumes)</managingEditor>
    <webMaster>zhaoying9402@gmail.com (Glumes)</webMaster>
    <lastBuildDate>Wed, 12 Sep 2018 09:19:09 +0800</lastBuildDate>
    
	<atom:link href="https://glumes.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android NDK 开发之 CMake 最佳实践</title>
      <link>https://glumes.com/post/android/cmake-best-practices/</link>
      <pubDate>Wed, 12 Sep 2018 09:19:09 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/cmake-best-practices/</guid>
      <description>&lt;p&gt;Android Studio 从 2.2 版本起开始支持 CMake ,可以通过 CMake 和 NDK 将 C/C++ 代码编译成底层的库，然后再配合 Gradle 的编译将库打包到 APK 中。&lt;/p&gt;

&lt;p&gt;这意味就不需要再编写 &lt;code&gt;.mk&lt;/code&gt; 文件来编译 &lt;code&gt;so&lt;/code&gt; 动态库了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>开源库之 OkHttp 源码分析</title>
      <link>https://glumes.com/post/android/okhttp-analysis/</link>
      <pubDate>Tue, 11 Sep 2018 22:13:45 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/okhttp-analysis/</guid>
      <description>&lt;p&gt;分析一波 OkHttp 的源码实现。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL ES 3.0 着色器语言 GLSL 学习 Mark </title>
      <link>https://glumes.com/post/opengl/opengl-glsl-3-mark/</link>
      <pubDate>Sun, 09 Sep 2018 15:20:42 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-glsl-3-mark/</guid>
      <description>&lt;p&gt;在之前的&lt;a href=&#34;https://glumes.com/post/opengl/opengl-glsl-2-mark/&#34;&gt;文章&lt;/a&gt;中， 主要介绍了 OpenGL ES 2.0 的 GLSL 语法，在 OpenGL ES 3.0 中语法又有了一些变化。&lt;/p&gt;

&lt;p&gt;本文的内容来自于《OpenGL ES 3.x 游戏开发 上卷》。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL ES 2.0 着色器语言 GLSL 学习 Mark </title>
      <link>https://glumes.com/post/opengl/opengl-glsl-2-mark/</link>
      <pubDate>Sun, 09 Sep 2018 15:07:20 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-glsl-2-mark/</guid>
      <description>&lt;p&gt;要想发挥 OpenGL ES 自定义渲染管线的功能，就得学会写 GLSL 着色器脚本。&lt;/p&gt;

&lt;p&gt;本文中的内容来自于 《Android 3D 游戏开发技术宝典 OpenGL ES 2.0》。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>开源库之 Retrofit 源码分析</title>
      <link>https://glumes.com/post/android/retrofit-analysis/</link>
      <pubDate>Sun, 09 Sep 2018 14:54:57 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/retrofit-analysis/</guid>
      <description>&lt;p&gt;分析一波 Retrofit 的源码实现。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 之 帧缓冲  使用实践</title>
      <link>https://glumes.com/post/opengl/opengl-framebuffer-object-usage/</link>
      <pubDate>Tue, 04 Sep 2018 22:28:11 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-framebuffer-object-usage/</guid>
      <description>&lt;p&gt;帧缓冲(Framebuffer Object)，简称 &lt;code&gt;FBO&lt;/code&gt;，在渲染绘制中， 图像最终都是绘制到 FBO 上的，一般都是默认的 FBO 上，也就是我们的屏幕。&lt;/p&gt;

&lt;p&gt;除此之外，还可以创建自己的 FBO，用来作为绘制的载体，当在自己的 FBO 上绘制好了之后，可以再把绘制内容显示到屏幕上，实现一个双缓冲的绘制。&lt;/p&gt;

&lt;p&gt;FBO 实际上是由颜色附件、深度附件、模板附件组成的，作为着色器各方面（一般包括颜色、深度、深度值）绘制结果存储的逻辑对象。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 之 EGL 使用实践</title>
      <link>https://glumes.com/post/opengl/opengl-egl-usage/</link>
      <pubDate>Sun, 02 Sep 2018 21:26:55 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-egl-usage/</guid>
      <description>&lt;p&gt;OpenGL 是跨平台的、专业的图形编程接口，而接口的实现是由厂商来完成的。&lt;/p&gt;

&lt;p&gt;而当我们使用这组接口完成绘制之后，要把结果显示在屏幕上，就要用到 &lt;code&gt;EGL&lt;/code&gt; 来完成这个转换工作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 之 GPUImage 源码分析</title>
      <link>https://glumes.com/post/opengl/opengl-gpuimage-analysis/</link>
      <pubDate>Sun, 02 Sep 2018 21:14:09 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-gpuimage-analysis/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/BradLarson/GPUImage&#34;&gt;GPUImage&lt;/a&gt; 是 iOS 上一个基于 OpenGL 进行图像处理的开源框架，后来有人借鉴它的想法实现了一个 Android 版本的 &lt;a href=&#34;https://github.com/CyberAgent/android-gpuimage&#34;&gt;GPUImage&lt;/a&gt; ，本文也主要对 Android 版本的 GPUImage 进行分析。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 中的静态代理和动态代理</title>
      <link>https://glumes.com/post/android/java-proxy-design-pattern/</link>
      <pubDate>Tue, 28 Aug 2018 22:55:49 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/java-proxy-design-pattern/</guid>
      <description>&lt;p&gt;代理模式的使用场景如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当无法或不想直接访问某个对象或访问对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》碰撞检测之 AABB 包围盒</title>
      <link>https://glumes.com/post/opengl/opengl-axially-aligned-bounding-box/</link>
      <pubDate>Thu, 26 Jul 2018 12:47:49 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-axially-aligned-bounding-box/</guid>
      <description>&lt;p&gt;在 OpenGL 的世界模型中，同时绘制了多个物体，那么怎么去检测物体之间是否触碰了，不同于在平面之间的触碰，OpenGL 是在三维世界里面的触碰，接下来就继续深入理解 OpenGL 中的碰撞检测相关知识~~~&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 之 Bitmap 操作</title>
      <link>https://glumes.com/post/android/android-jni-bitmap-operation/</link>
      <pubDate>Wed, 25 Jul 2018 13:36:50 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-bitmap-operation/</guid>
      <description>&lt;p&gt;在 Android 中通过 JNI 去操作 Bitmap。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》光照系列之效果混合</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-light-mix/</link>
      <pubDate>Tue, 24 Jul 2018 09:39:10 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-light-mix/</guid>
      <description>&lt;p&gt;在前面的系列文章中，分别介绍了 OpenGL 的环境光、散射光、镜面光。&lt;/p&gt;

&lt;p&gt;现在尝试将这些光照效果混合起来，让整个场景显得更加逼真。&lt;/p&gt;

&lt;p&gt;具体的效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/glumes-com/image/upload/v1532360616/light_mix_xmv86l.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》光照系列之镜面光</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-specular-light/</link>
      <pubDate>Mon, 23 Jul 2018 23:11:20 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-specular-light/</guid>
      <description>&lt;p&gt;在前面的文章中介绍了 OpenGL 的&lt;a href=&#34;https://glumes.com/post/opengl/opengl-tutorial-ambient-light/&#34;&gt;环境光&lt;/a&gt;和&lt;a href=&#34;https://glumes.com/post/opengl/opengl-tutorial-diffuse-light/&#34;&gt;散射光&lt;/a&gt;，现在就是最后一个镜面光了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title> 《OpenGL ES 3.x 游戏开发》 光照系列之散射光</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-diffuse-light/</link>
      <pubDate>Sun, 22 Jul 2018 23:27:04 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-diffuse-light/</guid>
      <description>&lt;p&gt;在前面的文章中介绍了 OpenGL 中的环境光，现在就是散射光了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》光照系列之环境光</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-ambient-light/</link>
      <pubDate>Sat, 21 Jul 2018 22:45:03 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-ambient-light/</guid>
      <description>&lt;p&gt;在 OpenGL 中使用光照。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 深度测试与精度值的那些事</title>
      <link>https://glumes.com/post/opengl/opengl-depth-test/</link>
      <pubDate>Fri, 20 Jul 2018 14:50:22 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-depth-test/</guid>
      <description>&lt;p&gt;在 OpenGL 世界里，使用深度测试可以来防止被阻挡的面渲染到其他面的前面。&lt;/p&gt;

&lt;p&gt;直接看一个没有使用深度测试的绘制：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/glumes-com/image/upload/v1532052034/code/undepth_test.gif&#34; alt=&#34;未开启深度测试的情况&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按照计划是绘制一个封闭的立方体，六个面都是有的，可从上面的效果来看并不是，立方体的有些面丢失了，只有后面的那个面，前面的面没了。&lt;/p&gt;

&lt;p&gt;这就是在没有开启深度测试的情况下，本来应该被遮挡的，绘制在后面的面却绘制到了其他面之上。&lt;/p&gt;

&lt;p&gt;要解决这种问题，就得使用深度测试了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 优化项之面剔除和注意点</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-face-culling-usage/</link>
      <pubDate>Thu, 19 Jul 2018 11:45:15 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-face-culling-usage/</guid>
      <description>&lt;p&gt;现在我们用 OpenGL 绘制了如下的立方体：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/glumes-com/image/upload/v1526832824/code/rotate_camera_with_cube.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不管我们怎么旋转立方体，从任何一个方向去看它，最多都只能看到三个面。&lt;/p&gt;

&lt;p&gt;那么对于 OpenGL 来说，那看不到的另外三个面完全可以不用绘制它，从而提高绘制的性能。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》 顶点数组对象 VAO 的使用</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-vertex-array-object-usage/</link>
      <pubDate>Wed, 18 Jul 2018 23:16:22 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-vertex-array-object-usage/</guid>
      <description>&lt;p&gt;在之前使用 &lt;a href=&#34;https://glumes.com/post/opengl/opengl-tutorial-vertex-buffer-object-usage/&#34;&gt;OpenGL 顶点缓冲区 VBO 的使用&lt;/a&gt; 为顶点坐标、纹理坐标分别绑定了顶点缓冲区，并且在 onDrawFrame 方法里面也要分别为顶点坐标、纹理坐标指定数据。&lt;/p&gt;

&lt;p&gt;这就存在了一些重复的操作。&lt;/p&gt;

&lt;p&gt;在 OpenGL ES 3.0 可以使用顶点数组对象来解决这一问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》顶点缓冲区 VBO 的使用</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-vertex-buffer-object-usage/</link>
      <pubDate>Tue, 17 Jul 2018 22:28:37 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-vertex-buffer-object-usage/</guid>
      <description>&lt;p&gt;在之前的绘制过程中，首先都需要将物体的顶点数据保存在内存中，然后 &lt;code&gt;glDrawArrays&lt;/code&gt; 或 &lt;code&gt;glDrawElements&lt;/code&gt; 绘制前，将顶点数据送入到显存中，这样会存在 I/O 开销较大的问题，性能也不够好。&lt;/p&gt;

&lt;p&gt;可以将顶点数据存放在顶点缓冲区中，就不需要在每次绘制前把顶点数据复制进显存，而是在初始化顶点缓冲区对象时一次性将顶点数据送入显存，每次绘制时直接使用显存中的数据，可以大大提高渲染性能。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》之颜色混合和使用</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-color-blend/</link>
      <pubDate>Mon, 16 Jul 2018 11:13:19 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-color-blend/</guid>
      <description>&lt;p&gt;在 Android 中有一个类 PorterDuffXfermode ，它是用来设置颜色混合方式的，也就是在已有颜色的基础上再绘制一笔颜色，这两个颜色是如何进行混合的，是新绘制的颜色覆盖了原有颜色，还是新绘制的颜色和原有颜色混合组成另一种颜色呢。&lt;/p&gt;

&lt;p&gt;在 OpenGL 中同样有这样颜色混合的问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 中的线程操作</title>
      <link>https://glumes.com/post/android/android-jni-thread-operation/</link>
      <pubDate>Sun, 15 Jul 2018 14:12:25 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-thread-operation/</guid>
      <description>&lt;p&gt;学习一下如何在 Native 代码中使用线程。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》之利用 Alpha 透明度进行测试</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-alpha-test/</link>
      <pubDate>Fri, 13 Jul 2018 09:41:22 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-alpha-test/</guid>
      <description>&lt;p&gt;在前面的博客文章中有提到 &lt;a href=&#34;https://glumes.com/post/opengl/opengl-tutorial-scissor-test/&#34;&gt;OpenGL 裁剪测试及注意点&lt;/a&gt;，并且裁剪测试只能裁剪一个矩形区域，相当于就是把整个内容都绘制上去了，但是透过一个小矩形区域来看绘制的物体。&lt;/p&gt;

&lt;p&gt;除了透过矩形区域，还可以实现透过任意形状区域来观察物体，这就是要用到 OpenGL 的 Alpha 透明度测试。&lt;/p&gt;

&lt;p&gt;关于 Alpha 透明度测试，在 用 &lt;a href=&#34;https://glumes.com/post/opengl/opengl-handle-video-frame-and-replace-content/&#34;&gt;OpenGL 对视频帧内容进行替换&lt;/a&gt; 也用实践用到过。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 OpenGL 对视频帧内容进行替换</title>
      <link>https://glumes.com/post/opengl/opengl-handle-video-frame-and-replace-content/</link>
      <pubDate>Thu, 12 Jul 2018 16:59:47 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-handle-video-frame-and-replace-content/</guid>
      <description>&lt;p&gt;在群里面有人提到了这么一个实现：现有一段素材视频，想要对视频中的某个内容进行替换，换成自己的图片，这个怎么用 OpenGL 去实现呢？&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL ES 学习资源分享</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-share/</link>
      <pubDate>Wed, 11 Jul 2018 14:25:52 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-share/</guid>
      <description>&lt;p&gt;学习了一段时间的 OpenGL ES，并在公司的项目中得到了运用，也算是有了一些积累，现在分享一些当初学习的资源，大家一起来学习，共同交流进步。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》 裁剪测试及注意点</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-scissor-test/</link>
      <pubDate>Tue, 03 Jul 2018 21:35:34 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-scissor-test/</guid>
      <description>&lt;p&gt;在 OpenGL 中启用裁剪测试可以在屏幕或者帧缓冲上指定一个矩形区域，然后在该矩形区域内绘制，只有在该区域内的片元才有机会最终进入帧缓冲，不在该区域内的将会被丢弃。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《OpenGL ES 3.x 游戏开发》 3D 模型加载和渲染</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-import-3d-object/</link>
      <pubDate>Mon, 02 Jul 2018 23:37:16 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-import-3d-object/</guid>
      <description>&lt;p&gt;在使用 OpenGL 绘制时，我们最多绘制的是一些简单的图形，比如三角形、圆形、立方体等，因为这些图形的顶点数量不多，还是可以手动的写出那些顶点的，可要是绘制一些复杂图形该怎么办呢？&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin 中的 run、let、with、apply、also、takeIf、takeUnless 语法糖使用和原理分析</title>
      <link>https://glumes.com/post/android/kotlin-syntactic-sugar-usage-and-analysis/</link>
      <pubDate>Fri, 29 Jun 2018 20:31:53 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/kotlin-syntactic-sugar-usage-and-analysis/</guid>
      <description>&lt;p&gt;在 Kotlin 有一些可以简化代码的语法糖，比如 run、let、with、apply、also、takeIf、takeUnless  等。&lt;/p&gt;

&lt;p&gt;再不明白这些语法糖的情况下去看 Kotlin 代码就会一脸懵逼，可当明白之后就会觉得原来可以这样简化。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 的 glDrawElements  绘制方法</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-gldrawelements-method/</link>
      <pubDate>Fri, 25 May 2018 19:47:29 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-gldrawelements-method/</guid>
      <description>&lt;p&gt;在之前的绘制中，我们都是通过 &lt;code&gt;glDrawArrays&lt;/code&gt; 方法来实现的，它会按照我们传入的顶点顺序和指定的绘制方式进行绘制。&lt;/p&gt;

&lt;p&gt;回顾一下之前提到的绘制类型：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绘制类型&lt;/th&gt;
&lt;th&gt;绘制方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GL_POINTS&lt;/td&gt;
&lt;td&gt;将传入的顶点坐标作为单独的点绘制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GL_LINES&lt;/td&gt;
&lt;td&gt;将传入的坐标作为单独线条绘制，ABCDEFG六个顶点，绘制AB、CD、EF三条线&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GL_LINE_STRIP&lt;/td&gt;
&lt;td&gt;将传入的顶点作为折线绘制，ABCD四个顶点，绘制AB、BC、CD三条线&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GL_LINE_LOOP&lt;/td&gt;
&lt;td&gt;将传入的顶点作为闭合折线绘制，ABCD四个顶点，绘制AB、BC、CD、DA四条线。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GL_TRIANGLES&lt;/td&gt;
&lt;td&gt;将传入的顶点作为单独的三角形绘制，ABCDEF绘制ABC,DEF两个三角形&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GL_TRIANGLE_STRIP&lt;/td&gt;
&lt;td&gt;将传入的顶点作为三角条带绘制，ABCDEF绘制ABC,BCD,CDE,DEF四个三角形&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GL_TRIANGLE_FAN&lt;/td&gt;
&lt;td&gt;将传入的顶点作为扇面绘制，ABCDEF绘制ABC、ACD、ADE、AEF四个三角形&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 学习系列---观察矩阵</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-view-matrix/</link>
      <pubDate>Tue, 22 May 2018 12:04:10 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-view-matrix/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;https://glumes.com/post/opengl/opengl-tutorial-projection-matrix/&#34;&gt;OpenGL 投影矩阵&lt;/a&gt; 这篇文章中，讲述了 OpenGL 坐标系统中的投影矩阵，有两种类型的投影矩阵，分别是正交投影和透视投影。&lt;/p&gt;

&lt;p&gt;这两种投影实质上是两种类型的裁剪空间，分别创建对应视景体对物体坐标进行裁剪，位于裁剪空间内的才会被映射到屏幕上，如下图所示：（图片来源：&lt;a href=&#34;https://glumpy.github.io/modern-gl.html&#34;&gt;https://glumpy.github.io/modern-gl.html&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/glumes-com/image/upload/v1526483191/ViewFrustum_gvy6aq.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当定义裁剪空间视景体时，我们都需要提供近平面和远平面的距离，这里的近和远都是指相对于&lt;code&gt;视点&lt;/code&gt;的，视点也就是我们这篇文章要讲到的摄像机。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 调用时的异常处理</title>
      <link>https://glumes.com/post/android/android-jni-exception-handle/</link>
      <pubDate>Wed, 16 May 2018 17:55:52 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-exception-handle/</guid>
      <description>&lt;p&gt;Android JNI 调用时的异常主要有如下两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Native 代码调用 Java 层代码时发生了异常要处理&lt;/li&gt;
&lt;li&gt;Native 代码自己抛出了一个异常让 Java 层去处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 中的引用管理</title>
      <link>https://glumes.com/post/android/android-jni-reference-manage-rules/</link>
      <pubDate>Wed, 16 May 2018 17:50:06 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-reference-manage-rules/</guid>
      <description>&lt;p&gt;在 Native 代码中有时候会接收 Java 传入的引用类型参数，有时候也会通过 NewObject 方法来创建一个 Java 的引用类型变量。&lt;/p&gt;

&lt;p&gt;在编写 Native 代码时，要注意这个代表 Java 数据结构类型的引用在使用时会被 GC 回收的可能性。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android  JNI 调用时缓存字段和方法 ID</title>
      <link>https://glumes.com/post/android/android-jni-cache-fieldid-and-methodid/</link>
      <pubDate>Mon, 07 May 2018 10:39:50 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-cache-fieldid-and-methodid/</guid>
      <description>&lt;p&gt;在 JNI 去调用 Java 的方法和访问字段时，最先要做的操作就是获得对应的类以及对应的方法 id。&lt;/p&gt;

&lt;p&gt;事实上，通过 FindClass 、GetFieldID、GetMethodID 去找到对应的信息是很耗时的，如果方法被频繁调用，那么肯定不能每次都去查找对应的信息，有必要将它们缓存起来，在下一次调用时，直接使用缓存内容就好了。&lt;/p&gt;

&lt;p&gt;缓存有两种方式，分别是使用时缓存和初始化时缓存。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 通过 JNI 调用 Java 类的构造方法和父类的方法</title>
      <link>https://glumes.com/post/android/android-jni-invoke-constructor-method-and-super-method/</link>
      <pubDate>Mon, 07 May 2018 10:32:01 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-invoke-constructor-method-and-super-method/</guid>
      <description>&lt;p&gt;Android 还可以通过 JNI 来调用 Java 一个类的构造方法，从而创建一个 Java 类。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 通过 JNI 访问 Java 字段和方法调用</title>
      <link>https://glumes.com/post/android/android-jni-access-field-and-method/</link>
      <pubDate>Mon, 07 May 2018 10:27:08 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-access-field-and-method/</guid>
      <description>&lt;p&gt;在前面的两篇文章中，介绍了 Android 通过 JNI 进行基础类型、字符串和数组的相关操作，并描述了 Java 和 Native 在类型和签名之间的转换关系。&lt;/p&gt;

&lt;p&gt;有了之前那些基础，就可以实现 Java 和 Native 的相互调用了，在 Native 中去访问 Java 类的字段并调用相应的方法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 数组 操作</title>
      <link>https://glumes.com/post/android/android-jni-array-operation/</link>
      <pubDate>Mon, 07 May 2018 10:21:22 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-array-operation/</guid>
      <description>&lt;p&gt;JNI 中有两种数组操作，基础数据类型数组和对象数组，JNI 对待基础数据类型数组和对象数组是不一样的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 基本操作 </title>
      <link>https://glumes.com/post/android/android-jni-basic-operation/</link>
      <pubDate>Mon, 07 May 2018 09:44:57 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-basic-operation/</guid>
      <description>&lt;p&gt;自从 Android Studio 升级到 2.3 版本以后，使用 CMake 进行编译就方便多了，不需要再写 Android.mk 了，也不需要用 javah 来生成头文件了，直接写好 native 方法，快捷方式就可以生成对应的 C++ 方法，只要专注写好 C++ 代码，CMake 就可以指定的 CPU 架构生成对应的 SO 库。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Camera 模型及 API 接口演变</title>
      <link>https://glumes.com/post/android/android-camrea-api-evolution/</link>
      <pubDate>Thu, 12 Apr 2018 13:13:57 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-camrea-api-evolution/</guid>
      <description>&lt;p&gt;要了解 Android Camear 相机模型的演变，首先还是得了解硬件抽象层 HAL 相关的知识内容。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 相机开发中的尺寸和方向问题</title>
      <link>https://glumes.com/post/android/android-camera-aspect-ratio--and-orientation/</link>
      <pubDate>Tue, 10 Apr 2018 16:09:32 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-camera-aspect-ratio--and-orientation/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 Android Camera 开发中，两个比较闹心的问题就是尺寸和方向了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 学习系列---纹理</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-texture/</link>
      <pubDate>Wed, 21 Mar 2018 23:08:02 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-texture/</guid>
      <description>&lt;p&gt;接下来探索纹理了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>搭建 Android 反编译环境</title>
      <link>https://glumes.com/post/android/setup-android-crack-environment/</link>
      <pubDate>Wed, 31 Jan 2018 15:47:59 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/setup-android-crack-environment/</guid>
      <description>&lt;p&gt;在 MAC 上搭建 Android 反编译环境主要就是三个东西：&lt;code&gt;apktool&lt;/code&gt; 、&lt;code&gt;dex2jar&lt;/code&gt; 、&lt;code&gt;jd-gui&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解使用MVP架构</title>
      <link>https://glumes.com/post/android/understand-mvp-architecture/</link>
      <pubDate>Wed, 31 Jan 2018 15:42:28 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/understand-mvp-architecture/</guid>
      <description>&lt;p&gt;在安卓开发中使用 MVP 模式已经非常普遍了，网上关于 MVP 的讲解也相当多了，不过看得再多还是自己写一遍比较熟练。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>编译安卓源码</title>
      <link>https://glumes.com/post/android/build-android-source-code/</link>
      <pubDate>Wed, 31 Jan 2018 15:31:44 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/build-android-source-code/</guid>
      <description>&lt;p&gt;花了一两天时间终于在 Mac 上成功编译了 Android 主线最新代码，中间遇到了不少问题，也查阅了好多资料，总算是成功了，看到模拟器启动的那一刻还是挺激动的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>安卓异步之RxJava</title>
      <link>https://glumes.com/post/android/android-rxjava/</link>
      <pubDate>Wed, 31 Jan 2018 15:26:16 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-rxjava/</guid>
      <description>&lt;p&gt;不学习 RxJava 简直太落后了，参照网上的博客以及英文书籍《RxJavaEssentials》，开始了 RxJava 之旅 。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解状态机</title>
      <link>https://glumes.com/post/android/understand-state-machine/</link>
      <pubDate>Wed, 31 Jan 2018 15:20:14 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/understand-state-machine/</guid>
      <description>&lt;p&gt;理解状态机的原理及使用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 学习系列---投影矩阵</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-projection-matrix/</link>
      <pubDate>Wed, 24 Jan 2018 18:17:58 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-projection-matrix/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;https://glumes.com/post/opengl/opengl-tutorial-coordinate/&#34;&gt;OpenGL 坐标系统&lt;/a&gt; 文章中，根据点的坐标变换得出了如下的公式：&lt;/p&gt;

&lt;div&gt;$$ V_{clip}=M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local} $$&lt;/div&gt;

&lt;p&gt;这个公式每左乘一个矩阵，都代表了一种坐标系的变换。&lt;/p&gt;

&lt;p&gt;转化为着色器脚本语言如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;attribute vec4 a_Position;
uniform mat4 u_ModelMatrix;
uniform mat4 u_ProjectionMatrix;
uniform mat4 u_ViewMatrix;
void main()
{
    gl_Position  = u_ProjectionMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本篇文章就主要是对投影矩阵来分析的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 学习系列---坐标系统</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-coordinate-system/</link>
      <pubDate>Tue, 23 Jan 2018 17:44:53 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-coordinate-system/</guid>
      <description>&lt;p&gt;在前面绘制基本图形中，遇到了很明显的问题，圆形不像圆形，正多边形不像正多边形？就像下面图形一样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xqe3m.com1.z0.glb.clouddn.com/blog_opengl_result_five.png&#34; alt=&#34;http://7xqe3m.com1.z0.glb.clouddn.com/blog_opengl_result_five.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;好好的正五边形却东倒西歪的，这就是因为我们前面的绘制都是把它当成 二维 的绘制，而在 OpenGL 中却是绘制 三维的。在二维和三维之间还有个转换，而之前为了方便学习则忽略了这个转换，现在就要开始理解它了 —— &lt;code&gt;坐标系统&lt;/code&gt;！！&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>泸沽湖-丽江之行</title>
      <link>https://glumes.com/post/life/journey-with-lover/</link>
      <pubDate>Thu, 04 Jan 2018 14:20:04 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/life/journey-with-lover/</guid>
      <description>&lt;p&gt;元旦假期和亲爱的去了趟 泸沽湖-丽江。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker 基础知识</title>
      <link>https://glumes.com/post/docker/docker-summary/</link>
      <pubDate>Fri, 22 Dec 2017 16:24:03 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/docker/docker-summary/</guid>
      <description>&lt;p&gt;可以简单地将 Docker 理解为一种沙盒 Sandbox 。每个容器内运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。&lt;/p&gt;

&lt;p&gt;容器的创建和停止都十分快速，容器自身对资源的需求也十分有限，远远低于虚拟机，甚至把容器当做应用本身也没问题。&lt;/p&gt;

&lt;p&gt;Docker 容器在启动速度、硬盘使用、性能、系统支持量、隔离性等方面与传统的虚拟机相比都有明显的优势。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 学习系列---基本形状的绘制</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-draw-basic-shape/</link>
      <pubDate>Fri, 22 Dec 2017 16:21:16 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-draw-basic-shape/</guid>
      <description>&lt;p&gt;在之前的一篇博客中，讲述了 OpenGL 绘制一个点的流程及相关的代码，其中关于 OpenGL 程序编译部分都是可以在其他项目中接着复用的，接下来会讲到如何去绘制其他的基本图元。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenGL 学习系列---基础的绘制流程</title>
      <link>https://glumes.com/post/opengl/opengl-tutorial-draw-point/</link>
      <pubDate>Fri, 22 Dec 2017 16:19:28 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opengl/opengl-tutorial-draw-point/</guid>
      <description>&lt;p&gt;终于要开始探索奇妙的 3D 世界了，OpenGL 搞起。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 函数式编程</title>
      <link>https://glumes.com/post/python/python-functional-programming/</link>
      <pubDate>Fri, 22 Dec 2017 16:10:57 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/python/python-functional-programming/</guid>
      <description>&lt;p&gt;函数式编程是一种编程范式，不同于之前的面向对象编程。它是面向数学的抽象，也就是说，这里的&lt;code&gt;函数&lt;/code&gt;二字不再是我们编程语言中的函数，而是数学中的&lt;code&gt;函数&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 命令行参数解析工具 docopt</title>
      <link>https://glumes.com/post/python/python-docopt/</link>
      <pubDate>Fri, 22 Dec 2017 16:08:45 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/python/python-docopt/</guid>
      <description>&lt;p&gt;正如标题所言，docopt 是一个用来解析命令行参数的工具，当想要在 Python 程序后面附加参数时，就不需要再为此而发愁了。&lt;/p&gt;

&lt;p&gt;docopt 是一个开源的库，代码地址：&lt;a href=&#34;https://github.com/docopt/docopt&#34;&gt;https://github.com/docopt/docopt&lt;/a&gt;。它在 README 中就已经做了详细的介绍，并且还附带了很多例子可供学习，这篇文章也是翻译一下 README 中内容&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>FFmpeg 3.0 版本视频解码浅析 </title>
      <link>https://glumes.com/post/ffmpeg/ffmpeg-convert-mpeg-to-pcm/</link>
      <pubDate>Fri, 22 Dec 2017 16:05:30 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/ffmpeg/ffmpeg-convert-mpeg-to-pcm/</guid>
      <description>&lt;p&gt;有了上一篇文章基础，这里就只关注 FFmpeg 如何解析的具体实践了。&lt;/p&gt;

&lt;p&gt;在开始工程之前，第一步要做的就是编译 FFmpeg 源码，生成 Android 平台上使用的 so 库。&lt;/p&gt;

&lt;p&gt;在生成完了之后，导入 Android 工程项目中，并且配置 CMake 文件，添加对应的库，就可以开始开发了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>音视频编解码的那些基础理论</title>
      <link>https://glumes.com/post/ffmpeg/encode-and-decode-summary/</link>
      <pubDate>Fri, 22 Dec 2017 16:03:10 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/ffmpeg/encode-and-decode-summary/</guid>
      <description>&lt;p&gt;最近在研究学习 FFmpeg，从网上参考了好多资料，其中最了不起的就当属——&lt;a href=&#34;http://blog.csdn.net/leixiaohua1020&#34;&gt;雷霄骅&lt;/a&gt;大神了，若没有他的博文，别说入门了，可能连门在哪里都不知道，在此还是要表达一下对雷神的敬佩和敬仰。&lt;/p&gt;

&lt;p&gt;本文主要讲的是视频文件的解码，从视频文件的封装格式解码到原始数据格式，通过讲解涉及到的各种概念，从而理清整个思路和流程。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 Rxjava 封装 Dialog 以及 RxBinding 实现简要分析</title>
      <link>https://glumes.com/post/android/rxjava-wrapper-dialog/</link>
      <pubDate>Fri, 22 Dec 2017 16:00:05 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/rxjava-wrapper-dialog/</guid>
      <description>&lt;p&gt;之前有写过一篇文章：&lt;a href=&#34;http://www.glumes.com/wrapper-callback-by-rxjava/&#34;&gt;用 RxJava 封装回调方法 CallBack&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;RxJava 封装回调方法的大体思路就是：使用 Observable 的 create 方法来返回一个 Observable，在 create 方法内给事物设置回调接口，用 Observable 的 onNext 方法来接受回调接口所产生的内容。&lt;/p&gt;

&lt;p&gt;这样一来，通过 onNext 方法就把事物的回调方法转换到 Rxjava 对应的事件流里面了，再可以通过其他操作符，如 Map、FlatMap 等对事件流进行相应的转换。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 布局加载之 LayoutInflater</title>
      <link>https://glumes.com/post/android/android-layout-inflater/</link>
      <pubDate>Fri, 22 Dec 2017 15:55:08 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-layout-inflater/</guid>
      <description>&lt;p&gt;Activity 在界面创建时需要将 XML 布局文件中的内容加载进来，正如我们在 ListView 或者 RecyclerView 中需要将 Item 的布局加载进来一样，都是使用 LayoutInflater 来进行操作的。&lt;/p&gt;

&lt;p&gt;LayoutInflater 实例的获取有多种方式，但最终是通过&lt;code&gt;(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)&lt;/code&gt;来得到的，也就是说加载布局的 &lt;code&gt;LayoutInflater&lt;/code&gt; 是来自于系统服务的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 插件换肤原理及源码分析</title>
      <link>https://glumes.com/post/android/android-change-skin-by-plugin/</link>
      <pubDate>Fri, 22 Dec 2017 15:51:44 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-change-skin-by-plugin/</guid>
      <description>&lt;p&gt;在学习安卓插件化开发的路上，有一处风景是肯定要观赏的，那就是基于插件的应用换肤了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Service 启动过程源码分析（一）</title>
      <link>https://glumes.com/post/android/android-start-service/</link>
      <pubDate>Fri, 22 Dec 2017 15:40:19 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-start-service/</guid>
      <description>&lt;p&gt;Service 组件也是 Android 四大组件之一，它的启动过程分为显示和隐式两种。对于隐式启动的 Service 组件来说，我们只需要它的组件名称；对于显示启动的 Service 组件来说，我们需要知道它的类名称。&lt;/p&gt;

&lt;p&gt;Service 组件可以被 Activity 组件启动，也可以被其他的 Service 组件启动。同时，它既可以在启动它的 Activity 组件或者 Service 组件所在的应用程序中启动，也可以在一个新的应用程序进程中启动。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android StateMachine 状态机分析</title>
      <link>https://glumes.com/post/android/android-statemachine/</link>
      <pubDate>Fri, 22 Dec 2017 15:37:04 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-statemachine/</guid>
      <description>&lt;p&gt;之前就有写过一篇文章来学习状态机：&lt;a href=&#34;http://www.glumes.com/statemachine_learn/&#34;&gt;状态机学习&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在之后的工作中多次用到了 StateMachine 状态机，简单记录其原理。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android LruCache实现分析</title>
      <link>https://glumes.com/post/android/android-lrucache/</link>
      <pubDate>Fri, 22 Dec 2017 15:35:23 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-lrucache/</guid>
      <description>&lt;p&gt;LruCache 是安卓开发中常用到的缓存技术，LRU 的全名是 Least Recently Used，表示最近最少使用算法，也就是说当内存快到达阈值时，若某个对象最近很少使用的，那么它就会被回收掉以释放内存。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Activity 创建 Window 及添加 View 流程分析</title>
      <link>https://glumes.com/post/android/android-window-and-view/</link>
      <pubDate>Fri, 22 Dec 2017 15:33:22 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-window-and-view/</guid>
      <description>&lt;p&gt;在之前有分析过 Android 6.0 Launcher 启动 Activity 过程，文章的链接如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-1/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-2/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-3/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-4/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（四）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 系统服务启动 SystemServer</title>
      <link>https://glumes.com/post/android/android-system-server/</link>
      <pubDate>Fri, 22 Dec 2017 15:30:26 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-system-server/</guid>
      <description>&lt;p&gt;在之前 &lt;a href=&#34;http://www.glumes.com/android-servicemanager/&#34;&gt;Android 系统服务管理 ServiceManager&lt;/a&gt; 中学习了各种系统服务 Service 都是通过 &lt;code&gt;ServiceManager&lt;/code&gt; 来管理的，从 ServiceManager 中来获得系统服务的 Binder 对象引用。这内容涉及到了 &lt;code&gt;ContextImpl&lt;/code&gt; 类、&lt;code&gt;SystemServiceRegistry&lt;/code&gt; 类、&lt;code&gt;ServiceManager&lt;/code&gt; 类、&lt;code&gt;ServiceManagerNative&lt;/code&gt; 类等等。&lt;/p&gt;

&lt;p&gt;那么问题就来了，ServiceManager 所管理的那些 Service 的 Binder 对象引用又是何时注册添加的呢？&lt;/p&gt;

&lt;p&gt;事实上这些服务 Service 是 SystemServer 进程中启动的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 系统服务管理 ServiceManager</title>
      <link>https://glumes.com/post/android/android-service-manager/</link>
      <pubDate>Fri, 22 Dec 2017 15:27:11 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-service-manager/</guid>
      <description>&lt;p&gt;在应用程序编程时，经常使用到 getSystemService(String serviceName) 方法来获得一个系统服务，它的实现也是在 ContextImpl 中的，根据不同的参数返回不同的系统服务，这些系统服务都是由 ServiceManager 管理的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Material Desing 控件小结-2</title>
      <link>https://glumes.com/post/android/android-material-design-summary-2/</link>
      <pubDate>Fri, 22 Dec 2017 15:22:15 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-material-design-summary-2/</guid>
      <description>&lt;p&gt;总结一下 Material Design 控件使用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Material Desing 控件小结-1</title>
      <link>https://glumes.com/post/android/android-material-design-summary-1/</link>
      <pubDate>Fri, 22 Dec 2017 15:19:03 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-material-design-summary-1/</guid>
      <description>&lt;p&gt;总结一下 Material Design 控件使用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Binder Summary</title>
      <link>https://glumes.com/post/android/android-binder-summary/</link>
      <pubDate>Fri, 22 Dec 2017 10:50:43 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-binder-summary/</guid>
      <description>&lt;p&gt;Binder 是什么？在英文中 Binder 是 粘合剂 的意思，表示将两样东西粘在一起。而在 Android 开发中，Binder 的意思多了去了。不同的角度有着不同的解释。&lt;/p&gt;

&lt;p&gt;它既可以是 Android 中实现了 IBinder 接口的一个单纯的类，也可以是 Android 中进程跨进程通信（IPC）的一种方式，还可以看作是工作在内核态的 Linux 驱动 &lt;code&gt;/dev/binder&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dagger2 在 Android 中的使用</title>
      <link>https://glumes.com/post/android/android-dagger-use/</link>
      <pubDate>Fri, 22 Dec 2017 10:47:52 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-dagger-use/</guid>
      <description>&lt;p&gt;Dagger2 是一个进行依赖注入的框架，早先是由 Square 公司写的，后来由 Google 来维护了，能由 Google 亲自维护的东西，肯定值得学习。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title> Android 6.0 Launcher 启动 Activity 过程分析小结（四）</title>
      <link>https://glumes.com/post/android/android-start-activity-from-launcher-4/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:49 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-start-activity-from-launcher-4/</guid>
      <description>&lt;p&gt;在如下三篇文章中过了一遍 Launcher 启动 Activity 的代码流程。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;start-activity-from-launcher-in-android-1&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;start-activity-from-launcher-in-android-2&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;start-activity-from-launcher-in-android-3&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（三）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而， 即使看过了多遍代码流程依旧有点云里雾里的感觉。不从整体上来把握，光抓住细节代码会始终不得要领。&lt;/p&gt;

&lt;p&gt;由于是从 Launcher 组件启动一个 Activity 组件，其中还需要与 ActivityManagerService 通信，而这三个部分都是位于不同的进程内，涉及进程间通信，因此可以将整个过程划分为三个不同的部分来分析，在 Launcher 进程内的操作，在 ActivityManagerService 进程内的操作，在创建的应用程序进程内的操作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Launcher 启动 Activity 过程源码分析（三）</title>
      <link>https://glumes.com/post/android/android-start-activity-from-launcher-3/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:45 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-start-activity-from-launcher-3/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-2/&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（二）&lt;/a&gt; 分析完了对待启动 Activity 组件的验证过程，获得组件信息，以及 ActivityRecord 添加至栈顶，将其他 Activity 进入中止状态，最后将待启动的 Activity 组件进入 &lt;code&gt;Resumed&lt;/code&gt;状态，然而，由于待启动的 Activity 组件的应用程序进程尚未启动，最后执行 &lt;code&gt;startSpecificActivityLocked&lt;/code&gt;方法创建进程。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Launcher 启动 Activity 过程源码分析（二）</title>
      <link>https://glumes.com/post/android/android-start-activity-from-launcher-2/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:42 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-start-activity-from-launcher-2/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-1/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（一）&lt;/a&gt; 分析完了 Launcher 组件中启动的步骤，接下来的环节是该 ActivityManagerService 出场了。&lt;/p&gt;

&lt;p&gt;通过 ActivityManagerNative.getDefault() 方法得到 ActivityManagerService 的代理对象后执行的 startActivity 方法，最终会发起进程间通信请求，通过 Binder 驱动，再调用 ActivityManagerService 中对应的方法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Launcher 启动 Activity 过程源码分析（一）</title>
      <link>https://glumes.com/post/android/android-start-activity-from-launcher-1/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:38 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-start-activity-from-launcher-1/</guid>
      <description>&lt;p&gt;当 Android 系统在启动时，会扫描系统特定目录，然后自动安装里面的 Android 应用程序。当系统启动完成之后，会启动一个 Home 应用程序来显示安装在系统中的 Android 应用程序。&lt;/p&gt;

&lt;p&gt;这个应用程序就是 Launcher 应用，也就是手机屏幕上显示的各种应用图标，Launcher 是 Android 系统启动的第一个应用程序。&lt;/p&gt;

&lt;p&gt;而当我们点击应用程序图标时，也就开启了从 Launcher 启动 Activity 的过程。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 RxJava 封装回调方法 CallBack</title>
      <link>https://glumes.com/post/android/rxjava-wrapper-callback/</link>
      <pubDate>Fri, 22 Dec 2017 10:38:34 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/rxjava-wrapper-callback/</guid>
      <description>&lt;p&gt;在知乎上看到这样一个问题：&lt;a href=&#34;https://www.zhihu.com/question/39492234&#34;&gt;RxJava正确的封装callback的方式应该是怎么样的？&lt;/a&gt;。虽说已经是个一年前的问题了，自己现在才遇到 (羞愧脸) 。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 硬件抽象层调用流程小结</title>
      <link>https://glumes.com/post/android/android-hal-summary/</link>
      <pubDate>Fri, 22 Dec 2017 10:31:13 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-hal-summary/</guid>
      <description>&lt;p&gt;Android 从 5.0 开始使用新的相机 API Camera2 来代替之前的旧版本，从而支持更多的特性。&lt;/p&gt;

&lt;p&gt;在学习新的 API 调用之外，也还是要了解一下 Android 底层发生了哪些变化，从而能够让我们对 API 的调用流程更加的清晰，知其所以然。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin 函数式编程与 Anko 构建布局实现原理分析</title>
      <link>https://glumes.com/post/android/kotlin-functional-programming-whth-anko/</link>
      <pubDate>Fri, 22 Dec 2017 10:26:57 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/kotlin-functional-programming-whth-anko/</guid>
      <description>&lt;p&gt;之前讲到了如何在 &lt;a href=&#34;http://www.glumes.com/kotlin-anko-usage/&#34;&gt;Kotlin 开发中使用 Anko 构建布局&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这一篇将是分析其原理。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin 使用 Anko 布局那些事</title>
      <link>https://glumes.com/post/android/kotlin-with-anko/</link>
      <pubDate>Fri, 22 Dec 2017 10:21:26 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/kotlin-with-anko/</guid>
      <description>&lt;p&gt;学习 Kotlin 应该都或多或少听过 Anko 这个开源库。&lt;/p&gt;

&lt;p&gt;使用 Anko 来构建界面会更加简单、快捷。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python、C&#43;&#43;、Android OpenCV 开发环境的配置</title>
      <link>https://glumes.com/post/opencv/setup_opencv_environment/</link>
      <pubDate>Fri, 22 Dec 2017 09:53:04 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/opencv/setup_opencv_environment/</guid>
      <description>&lt;p&gt;在 Mac 上折腾了一下 OpenCV 的配置，分别配置了 Python 、C++ 和 Android 上的开发环境，中间还遇到点坑，简要记录一下。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>