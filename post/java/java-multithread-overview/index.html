<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">


  <title>Java 显式锁 Lock 与条件队列</title>
  <meta property="og:title" content="Java 显式锁 Lock 与条件队列" />
  <meta name="twitter:title" content="Java 显式锁 Lock 与条件队列" />

  <meta name="description" content="在 Java 5.0 之前，在协调对共享对象的访问时可以使用的机制只有 synchronized 内置锁和 volatile 关键字。
Java 5.0 增加了一种新的机制：Lock  显式锁，当内置锁 synchronized 不适用时，它就可以作为一种新的选择。
回顾一下内置锁 synchronized 的使用：
// synchronized关键字用法示例
public synchronized void add(int t){// 同步方法
    this.v &#43;= t;
}

public static synchronized void sub(int t){// 同步静态方法
    value -= t;
}
public int decrementAndGet(){
    synchronized(obj){// 同步代码块
        return --v;
    }
}
内置锁不需要显式的获取和释放，任何一个对象都能作为一把内置锁。

当 synchronized 作用于普通方法时，锁对象是 this 。
当 synchronized 作用于静态方法时，锁对象是当前类的 Class 对象。
当 synchronized 作用于代码块时，锁对象是 synchronized(obj) 中的这个 obj 对象。

">
  <meta property="og:description" content="在 Java 5.0 之前，在协调对共享对象的访问时可以使用的机制只有 synchronized 内置锁和 volatile 关键字。
Java 5.0 增加了一种新的机制：Lock  显式锁，当内置锁 synchronized 不适用时，它就可以作为一种新的选择。
回顾一下内置锁 synchronized 的使用：
// synchronized关键字用法示例
public synchronized void add(int t){// 同步方法
    this.v &#43;= t;
}

public static synchronized void sub(int t){// 同步静态方法
    value -= t;
}
public int decrementAndGet(){
    synchronized(obj){// 同步代码块
        return --v;
    }
}
内置锁不需要显式的获取和释放，任何一个对象都能作为一把内置锁。

当 synchronized 作用于普通方法时，锁对象是 this 。
当 synchronized 作用于静态方法时，锁对象是当前类的 Class 对象。
当 synchronized 作用于代码块时，锁对象是 synchronized(obj) 中的这个 obj 对象。

">
  <meta name="twitter:description" content="在 Java 5.0 之前，在协调对共享对象的访问时可以使用的机制只有 synchronized 内置锁和 volatile 关键字。
Java 5.0 增加了一种新的机制：Lock  显式锁，当内置锁 synchronized 不适用时，它就可以作为一种新的选择。
回顾一下内置锁 synchronized 的使用：
// synchronized关键字用法示例
public …">
  <meta name="author" content=""/>
  <meta name="referrer" content="no-referrer" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://www.glumes.com/post/java/java-multithread-overview/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="星陨的博客" />

  <meta name="generator" content="Hugo 0.74.3" />
  <link rel="canonical" href="https://www.glumes.com/post/java/java-multithread-overview/" />
  <link rel="alternate" href="https://www.glumes.com/index.xml" type="application/rss+xml" title="星陨的博客">
  <link rel="stylesheet" href="https://www.glumes.com/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://www.glumes.com/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://www.glumes.com/css/main.css?t=126" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://www.glumes.com/css/pygment_highlights.css" />
  <link rel="stylesheet" href="https://www.glumes.com/css/highlight.min.css" />
  <link rel="stylesheet" href="https://www.glumes.com/css/prism.css?t=123" />
  <link rel="stylesheet" href="https://www.glumes.com/css/search.css" />
  

<link rel="stylesheet" href="https://res.cloudinary.com/glumes-com/raw/upload/v1516330613/website/css/prism.css" />






<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-84590324-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?9276c0ce2d3c49b591323abab4a32e1e";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
</script>



</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://www.glumes.com/">星陨的博客</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">目录</a>
              <div class="navlinks-children">
                
                  <a href="https://www.glumes.com/categories/android">Android</a>
                
                  <a href="https://www.glumes.com/categories/opencv">opencv</a>
                
                  <a href="https://www.glumes.com/categories/opengl">opengl</a>
                
                  <a href="https://www.glumes.com/categories/%e9%9f%b3%e8%a7%86%e9%a2%91%e5%bc%80%e5%8f%91">ffmpeg</a>
                
                  <a href="https://www.glumes.com/categories/python">python</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="生活" href="https://www.glumes.com/categories/life">生活</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="https://www.glumes.com/tags">标签</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="https://www.glumes.com/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="文章集" href="https://www.glumes.com/post/">文章集</a>
            </li>
          
        

        

        

        

      </ul>
    </div>

  </div>
</nav>





    
  
  
  




  
    <div id="header-big-imgs" data-num-img=1 data-img-src-1="https://image.glumes.com/images/2019/04/27/bc32fd77gy1fxdkqsi8boj20zk0nqn8o.jpg" ></div>
  

  <header class="header-section has-img">
    
      <div class="intro-header big-img">
        
        
        <div class="container">
          <div class="row">
              <div class="col-lg-12 col-md-12 col-md-offset-0">
                
                <div class="page-heading">
                
                  
                     <h1>Java 显式锁 Lock 与条件队列</h1>
                     
                    <span class="post-meta">
  Posted on November 19, 2018
  
</span>


                    
                  
                  
              </div>
            </div>
          </div>
        </div>
        <span class="img-desc" style="display: inline;"></span>
      </div>
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-12 col-md-12 col-md-offset-0">
            <div class="post-heading">
                <h1 align="center">Java 显式锁 Lock 与条件队列</h1>
                
                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">



        
      <div>
          
          
          <h5 id="tags" style="margin-top: 0px;">标签:
            
                <a href="https://www.glumes.com/tags/java/">Java</a> &nbsp;
            
          </h5>
          
      </div>

      <article role="main" class="blog-post" itemprop="articleBody" id="content">
        
        <p>在 Java 5.0 之前，在协调对共享对象的访问时可以使用的机制只有 <code>synchronized</code> 内置锁和 <code>volatile</code> 关键字。</p>
<p>Java 5.0 增加了一种新的机制：<code>Lock</code>  显式锁，当内置锁 <code>synchronized</code> 不适用时，它就可以作为一种新的选择。</p>
<p>回顾一下内置锁 synchronized 的使用：</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// synchronized关键字用法示例
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">synchronized</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">add</span>(<span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">t</span>){<span style="color:#93a1a1;font-style:italic">// 同步方法
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">this</span>.<span style="color:#268bd2">v</span> += <span style="color:#268bd2">t</span>;
}

<span style="color:#859900">public</span> <span style="color:#859900">static</span> <span style="color:#859900">synchronized</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">sub</span>(<span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">t</span>){<span style="color:#93a1a1;font-style:italic">// 同步静态方法
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#268bd2">value</span> -= <span style="color:#268bd2">t</span>;
}
<span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">decrementAndGet</span>(){
    <span style="color:#859900">synchronized</span>(<span style="color:#268bd2">obj</span>){<span style="color:#93a1a1;font-style:italic">// 同步代码块
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#859900">return</span> --<span style="color:#268bd2">v</span>;
    }
}
</code></pre></div><p>内置锁不需要显式的获取和释放，任何一个对象都能作为一把内置锁。</p>
<ul>
<li>当 synchronized 作用于普通方法时，锁对象是 this 。</li>
<li>当 synchronized 作用于静态方法时，锁对象是当前类的 Class 对象。</li>
<li>当 synchronized 作用于代码块时，锁对象是 synchronized(obj) 中的这个 obj 对象。</li>
</ul>
<hr>
<h2 id="显式锁-lock">显式锁 Lock</h2>
<p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，它定义了一组抽象的加锁方法。</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#859900">public</span> <span style="color:#859900">interface</span> <span style="color:#cb4b16">Lock</span>{
	    <span style="color:#93a1a1;font-style:italic">// 阻塞直到获得锁或者中断
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">lock</span>();
        <span style="color:#93a1a1;font-style:italic">// 阻塞直到获得锁或者中断异常
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">lockInterruptibly</span>() <span style="color:#859900">throws</span> <span style="color:#268bd2">InterruptedException</span>;
        <span style="color:#93a1a1;font-style:italic">// 只有锁可用时才获得，否则直接返回
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#859900;font-weight:bold">boolean</span> <span style="color:#268bd2">tryLock</span>();
        <span style="color:#93a1a1;font-style:italic">// 只有锁在指定时间内可用才获得，否则直接返回，中断时抛异常
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#859900;font-weight:bold">boolean</span> <span style="color:#268bd2">tryLock</span>(<span style="color:#859900;font-weight:bold">long</span> <span style="color:#268bd2">time</span>, <span style="color:#268bd2">TimeUnit</span> <span style="color:#268bd2">unit</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">InterruptedException</span>;
        <span style="color:#93a1a1;font-style:italic">// 释放锁
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">unlock</span>();
        <span style="color:#93a1a1;font-style:italic">// 返回一个绑定在这个锁上的条件
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#268bd2">Condition</span> <span style="color:#268bd2">newCondition</span>();
    }	
</code></pre></div><p>与内置锁不同，Lock 提供的锁有如下特性：</p>
<ul>
<li>无条件的</li>
<li>可轮询的</li>
<li>可定时的</li>
<li>可中断的</li>
</ul>
<p>并且加锁和解锁的方法都是显式的，而内置锁就隐式调用的。</p>
<p>Lock 有这些新的特性，对比的都是内置锁的痛点，通过 synchronized 来获得锁，如果得不到，就会一直阻塞，既没有超时机制，也不能通过中断来取消。</p>
<p>Lock 接口的标准使用形式如下：</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	    <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">lock</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLock</span>();
        <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">lock</span>();
        <span style="color:#859900">try</span> {
            <span style="color:#93a1a1;font-style:italic">// 更新对象状态
</span><span style="color:#93a1a1;font-style:italic"></span>            <span style="color:#93a1a1;font-style:italic">// 捕获异常，并在必要时恢复不变性条件
</span><span style="color:#93a1a1;font-style:italic"></span>        } <span style="color:#859900">finally</span> {
            <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">unlock</span>();
        }
</code></pre></div><p>Lock 的使用必须在 finally 块中释放锁，否则，如果在被保护的代码中抛出了异常，那么这个锁永远都无法释放。</p>
<p>当使用加锁时，还必须考虑在 try 块中抛出异常的情况，如果可能使对象处于某种不一致的状态，那么就需要更多的 try-catch 或者 try-finally 代码块。</p>
<p>Lock 接口提供的不同方法，实际上就对应了不同的特性。</p>
<h3 id="lock-锁的可轮询特性">Lock 锁的可轮询特性</h3>
<p>Lock 的 <code>tryLock()</code> 方法对应着可轮询的特性。</p>
<p><code>tryLock</code> 方法顾名思义就是去尝试获得锁，并且具有返回值，如果锁可用，则获取锁，并立即返回 true ，若不可用，立即返回 false 。</p>
<p>利用此特性可以实现可轮询地获取锁：</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">boolean</span> <span style="color:#268bd2">lockUse</span>(<span style="color:#859900">final</span> <span style="color:#268bd2">Runnable</span> <span style="color:#268bd2">task</span>){

        <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">lock1</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLock</span>();
        <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">lock2</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLock</span>();
        <span style="color:#93a1a1;font-style:italic">// 超时时间
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#859900;font-weight:bold">long</span> <span style="color:#268bd2">stopTime</span> = <span style="color:#268bd2">System</span>.<span style="color:#268bd2">nanoTime</span>() + <span style="color:#268bd2">TimeUnit</span>.<span style="color:#268bd2">MILLISECONDS</span>.<span style="color:#268bd2">toNanos</span>(<span style="color:#268bd2">100</span>);
        <span style="color:#859900">while</span> (<span style="color:#859900;font-weight:bold">true</span>){
            <span style="color:#859900">if</span> (<span style="color:#268bd2">lock1</span>.<span style="color:#268bd2">tryLock</span>()){
                <span style="color:#859900">try</span> {
                    <span style="color:#859900">if</span> (<span style="color:#268bd2">lock2</span>.<span style="color:#268bd2">tryLock</span>()){
                        <span style="color:#859900">try</span> {
                            <span style="color:#268bd2">task</span>.<span style="color:#268bd2">run</span>();
                            <span style="color:#859900">return</span> <span style="color:#859900;font-weight:bold">true</span>;
                        }<span style="color:#859900">finally</span> {
                            <span style="color:#268bd2">lock2</span>.<span style="color:#268bd2">unlock</span>();
                        }
                    }
                }<span style="color:#859900">finally</span> {
                    <span style="color:#268bd2">lock1</span>.<span style="color:#268bd2">unlock</span>();
                }
            }
            <span style="color:#93a1a1;font-style:italic">// 在
</span><span style="color:#93a1a1;font-style:italic"></span>            <span style="color:#859900">if</span> (<span style="color:#268bd2">System</span>.<span style="color:#268bd2">nanoTime</span>() &lt; <span style="color:#268bd2">stopTime</span>){
                <span style="color:#859900">return</span> <span style="color:#859900;font-weight:bold">false</span>;
            }
        }
    }
</code></pre></div><h3 id="lock-锁的可定时特性">Lock 锁的可定时特性</h3>
<p>Lock 的 <code>tryLock(long time, TimeUnit unit)</code> 方法对应着可轮询的特性。</p>
<p>带参数的 <code>tryLock</code> 方法会在一定时间范围内去尝试获得锁，如果锁可用，则获取锁，并立即返回 true ，若不可用，并且超出了等待时间就会返回 false 。</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">boolean</span> <span style="color:#268bd2">lockUse2</span>(<span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">time</span>,<span style="color:#859900">final</span> <span style="color:#268bd2">Runnable</span> <span style="color:#268bd2">task</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">InterruptedException</span> {
        <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">lock1</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLock</span>();
        <span style="color:#859900">if</span> (!<span style="color:#268bd2">lock1</span>.<span style="color:#268bd2">tryLock</span>(<span style="color:#268bd2">time</span>,<span style="color:#268bd2">TimeUnit</span>.<span style="color:#268bd2">MICROSECONDS</span>)){
            <span style="color:#859900">return</span> <span style="color:#859900;font-weight:bold">false</span>;
        }
        <span style="color:#859900">try</span> {
            <span style="color:#268bd2">task</span>.<span style="color:#268bd2">run</span>();
            <span style="color:#859900">return</span> <span style="color:#859900;font-weight:bold">true</span>;
        }<span style="color:#859900">finally</span> {
            <span style="color:#268bd2">lock1</span>.<span style="color:#268bd2">unlock</span>();
        }
    }
</code></pre></div><h3 id="lock-锁的可中断特性">Lock 锁的可中断特性</h3>
<p>Lock 的 <code>lockInterruptibly()</code> 方法对应着可中断的特性。</p>
<p>当通过 <code>lockInterruptibly</code> 方法去获得锁时，如果线程正在等待的过程中，那么 <code>Thread.interrupt()</code> 方法可以中断等待状态。</p>
<p>而 synchronized 内置锁，当线程处于等待某个锁的状态时是无法被中断的，只有一直等待下去。</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">boolean</span> <span style="color:#268bd2">lockUse3</span>(<span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">time</span>,<span style="color:#859900">final</span> <span style="color:#268bd2">Runnable</span> <span style="color:#268bd2">task</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">InterruptedException</span> {

        <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">lock1</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLock</span>();

        <span style="color:#268bd2">lock1</span>.<span style="color:#268bd2">lockInterruptibly</span>();
        <span style="color:#859900">try</span> {
            <span style="color:#268bd2">task</span>.<span style="color:#268bd2">run</span>();
            <span style="color:#859900">return</span> <span style="color:#859900;font-weight:bold">true</span>;
        }<span style="color:#859900">finally</span> {
            <span style="color:#268bd2">lock1</span>.<span style="color:#268bd2">unlock</span>();
        }
    }
</code></pre></div><h2 id="可重入锁-reentrantlock">可重入锁 ReentrantLock</h2>
<p>可重入锁 ReentrantLock 类实现了 Lock 接口，并且具有可重入的特性，另外，synchronized 的内置锁也具有可重入的特性。</p>
<p>可重入特性指的是同一线程的外层函数获得锁之后，内层递归函数仍然能够获取该锁，不受影响。</p>
<p>可重入锁能够避免死锁，比如：</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">ReentrantLockTest</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">Runnable</span>{

    <span style="color:#268bd2">ReentrantLock</span> <span style="color:#268bd2">lock</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLock</span>();

    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">get</span>(){
        <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">lock</span>();
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;get do something&#34;</span>);
        <span style="color:#268bd2">set</span>();
        <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">unlock</span>();
    }

    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">set</span>(){
        <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">lock</span>();
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;set do something&#34;</span>);
        <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">unlock</span>();
    }

    <span style="color:#268bd2">@Override</span>
    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">run</span>() {
        <span style="color:#268bd2">get</span>();
    }

    <span style="color:#859900">public</span> <span style="color:#859900">static</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">main</span>(<span style="color:#268bd2">String</span>[] <span style="color:#268bd2">args</span>) {
        <span style="color:#268bd2">ReentrantLockTest</span> <span style="color:#268bd2">test</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLockTest</span>();
        <span style="color:#859900">new</span> <span style="color:#268bd2">Thread</span>(<span style="color:#268bd2">test</span>).<span style="color:#268bd2">start</span>();
        <span style="color:#859900">new</span> <span style="color:#268bd2">Thread</span>(<span style="color:#268bd2">test</span>).<span style="color:#268bd2">start</span>();
        <span style="color:#859900">new</span> <span style="color:#268bd2">Thread</span>(<span style="color:#268bd2">test</span>).<span style="color:#268bd2">start</span>();
    }
}
</code></pre></div><p>在 get 方法中调用 set 方法，这两个方法会相同锁的 <code>lock</code> 方法。如果 ReentrantLock 不具备可重入特性，那么 set 方法中的 lock 调用就会阻塞，导致 get 方法不能执行到释放锁的步骤，从而死锁了。</p>
<h2 id="公平锁与非公平锁">公平锁与非公平锁</h2>
<p>ReentrantLock 根据构造参数的不同可以实现公平锁与非公平锁，构造函数传入 true 就是公平锁，false 就是非公平锁。</p>
<p>默认情况下，ReentrantLock 是非公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许 <code>插队</code> :</p>
<blockquote>
<p>当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。</p>
</blockquote>
<p>非公平的 ReentrantLock 并不提倡 <code>插队</code> 行为，但无法防止某个线程在合适的时候进行插队。</p>
<p>在公平的锁中，如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将被放入队列中。在非公平的锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。</p>
<h3 id="synchronized-与-reentrantlock-之间的选择">synchronized 与 ReentrantLock 之间的选择</h3>
<p>ReentrantLock 在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性等，在性能上，ReentrantLock 似乎优于内置锁。</p>
<p>但与显示锁相比，内置锁仍然具有很大的优势。内置锁更被人所熟悉，并且简洁紧凑，JVM 也会对内置进行优化。</p>
<p>在一些内置锁无法满足需求的情况下，ReentrantLock 可以作为一种高级工具来使用。或者当需要使用 ReentrantLock 的一些高级功能时，否则，还是应该优先使用 synchronized 。</p>
<h2 id="读写锁-readwritelock">读写锁 ReadWriteLock</h2>
<p>ReentrantLock 实现了一种标准的互斥锁：</p>
<blockquote>
<p>每次最多只有一个线程能持有 ReentrantLock 。</p>
</blockquote>
<p>对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁规则，因此也就不必要地限制了并发性。</p>
<p>互斥是一种保守的加锁策略，虽然可以避免 <code>写 / 写</code> 冲突和 <code>写 / 读</code> 冲突，但同样也避免了 <code>读 / 读</code> 冲突。</p>
<p>在许多情况下，数据结构上的操作都是 <code>读操作</code> ，虽然它们也是可变的并且在某些情况下被修改，但其中大多数访问操作都是读操作。如果此时能够放宽加锁需求，允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。</p>
<p>只要每个线程都能确保读取到最新的数据，并且在读取数据时不会有其他线程修改数据，那么就不会发生问题，在这种情况下就可以使用 读 / 写锁：<code>ReadWriteLock</code> 。</p>
<blockquote>
<p>一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。</p>
</blockquote>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">interface</span> <span style="color:#cb4b16">ReadWriteLock</span> {
    <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">readLock</span>();
    <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">writeLock</span>();
}
</code></pre></div><p>在读 / 写锁实现的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。</p>
<p>与 Lock 接口一样，ReadWriteLock 也有多种不同的实现方式。</p>
<p><code>ReentrantReadWriteLock</code> 类实现了 ReadWriteLock 接口，它为读取锁和写入锁都提供了可重入的加锁语义。</p>
<p>与 ReentrantLock 类似，ReentrantReadWriteLock 在构造时也可以选择是一个非公平的锁（默认）还是一个公平的锁。</p>
<p>在公平的锁中，等待时间最长的线程将优先获得锁，如果这个锁由读线程持有，而另一个线程请求写入锁，那么其他读线程都不能获取读取锁，直到写线程使用完并且释放了写入锁。</p>
<p>在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但从读线程升级为写线程则是不可以的，会导致死锁。</p>
<h3 id="读写锁-与-独占锁之间的选择">读写锁 与 独占锁之间的选择</h3>
<p>读 / 写锁是一种性能优化措施，在一些特定的情况下能够实现更高的并发性。</p>
<p>在实际情况中，对于在多处理器系统上被频繁读取的数据结构，读 / 写锁能够提高性能。而在其他情况下，读 / 写锁的性能比独占锁的性能要略差一点，这是因为它们的复杂性更高。</p>
<p>在读 / 写锁 和 独占锁之间做选择时，最好先对程序进行分析，如果读 / 写并没有提高性能，那么使用独占锁也可以。</p>
<p>下面是使用 <code>ReentrantReadWriteLock</code> 来包装一 Map ，让它能够在多个线程之间被安全地共享，并且仍能够避免 读 / 写 或 写 / 写冲突。</p>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">ReadWriteMap</span>&lt;<span style="color:#268bd2">K</span>,<span style="color:#268bd2">V</span>&gt; {
    <span style="color:#859900">private</span> <span style="color:#859900">final</span> <span style="color:#268bd2">Map</span>&lt;<span style="color:#268bd2">K</span>,<span style="color:#268bd2">V</span>&gt; <span style="color:#268bd2">map</span>;
    <span style="color:#859900">private</span> <span style="color:#859900">final</span> <span style="color:#268bd2">ReadWriteLock</span> <span style="color:#268bd2">lock</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantReadWriteLock</span>();
    <span style="color:#859900">private</span> <span style="color:#859900">final</span> <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">r</span> = <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">readLock</span>();
    <span style="color:#859900">private</span> <span style="color:#859900">final</span> <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">w</span> = <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">writeLock</span>();

    <span style="color:#859900">public</span> <span style="color:#268bd2">ReadWriteMap</span>(<span style="color:#268bd2">Map</span>&lt;<span style="color:#268bd2">K</span>,<span style="color:#268bd2">V</span>&gt; <span style="color:#268bd2">map</span>){
        <span style="color:#859900">this</span>.<span style="color:#268bd2">map</span> = <span style="color:#268bd2">map</span>;
    }

    <span style="color:#859900">public</span> <span style="color:#268bd2">V</span> <span style="color:#268bd2">put</span>(<span style="color:#268bd2">K</span> <span style="color:#268bd2">key</span>,<span style="color:#268bd2">V</span> <span style="color:#268bd2">value</span>){
        <span style="color:#268bd2">w</span>.<span style="color:#268bd2">lock</span>();
        <span style="color:#859900">try</span> {
            <span style="color:#859900">return</span> <span style="color:#268bd2">map</span>.<span style="color:#268bd2">put</span>(<span style="color:#268bd2">key</span>,<span style="color:#268bd2">value</span>);
        } <span style="color:#859900">finally</span> {
          <span style="color:#268bd2">w</span>.<span style="color:#268bd2">unlock</span>();
        }
    }

    <span style="color:#859900">public</span> <span style="color:#268bd2">V</span> <span style="color:#268bd2">get</span>(<span style="color:#268bd2">Object</span> <span style="color:#268bd2">key</span>){
        <span style="color:#268bd2">r</span>.<span style="color:#268bd2">lock</span>();
        <span style="color:#859900">try</span> {
            <span style="color:#859900">return</span> <span style="color:#268bd2">map</span>.<span style="color:#268bd2">get</span>(<span style="color:#268bd2">key</span>);
        } <span style="color:#859900">finally</span> {
            <span style="color:#268bd2">r</span>.<span style="color:#268bd2">unlock</span>();
        }
    }
}
</code></pre></div><h3 id="小结">小结</h3>
<p>与内置锁相比，显示的 Lock 提供了一些拓展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列有着更好的控制。但 ReentrantLock 不能完全替代 synchronized ，只有在 synchronized 无法满足需求时，才应该使用它。</p>
<p>读 / 写锁允许多个线程并发地访问被保护的对象，当访问以读取操作为主的数据结构时，它能够提高程序的可伸缩性。</p>
<hr>
<h2 id="条件谓词与条件队列">条件谓词与条件队列</h2>
<p>条件谓词和条件队列是平时接触比较少的内容，这里也一并记录下。</p>
<h3 id="状态依赖性的管理">状态依赖性的管理</h3>
<p>依赖状态的操作可以一直阻塞直到可以继续执行，这比使它们先失败再实现起来更为方便且不宜出错。</p>
<p>内置的条件队列可以使线程一直阻塞，直到对象进入某个进程可以继续执行的状态，并且当被阻塞的线程可以执行时再唤醒它们。</p>
<p><code>条件队列</code> 来源于：它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。传统队列的元素是一个个数据，而与之不同的是，条件队列中的元素是一个个正在等待相关条件的线程。</p>
<p>正如每个 Java 对象都可以作为一个锁，每个对象同样可以作为一个条件队列，并且 Object 中的 wait、notify 和 notifyAll 方法就构成了内部条件队列的 API 。</p>
<p>对象的内置锁与其内部条件队列是相互关联的，要调用对象 X 中条件队列的任何一个方法，必须持有对象 X 上的锁。这是因为 “等待由状态构成的条件” 与  “维护状态一致性” 这两种机制必须被紧密绑定在一起：只有能对状态进行检查时，才能在某个条件上等待，并且只有能修改状态时，才能从条件等待中释放另一个线程。</p>
<p>条件队列使构建高效以及高可响应性的状态依赖类变得更容易，但同时也很容易被不正确地使用。</p>
<blockquote>
<p>在条件等待中存在一种重要的三元关系，包括加锁、wait 方法和一个条件谓词。在条件谓词中包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁。锁对象和条件队列对象（即调用 wait 和 notify 等方法所在的对象）必须是同一个对象。</p>
</blockquote>
<blockquote>
<p>每一次 wait 调用都会隐式地与特定的条件谓词关联起来。当调用某个特定条件谓词的 wait 时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。</p>
</blockquote>
<p>避免过早唤醒，或者唤醒之后，条件谓词并不为真，使用 while 循环在调用 wait 方法。</p>
<p>线程在条件谓词不为真的情况下也可以反复地醒来，因此必须在一个循环中调用 wait ，并在每次迭代中都检测条件谓词。</p>
<h3 id="通知">通知</h3>
<p>每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知。</p>
<p>优先使用 notifyAll 而不是 notify 。</p>
<p>只有同时满足以下两个条件时，才能用单一的 notify 而不是 notifyAll 。</p>
<ul>
<li>所有等待线程的类型都相同。只有一个条件谓词与条件队列相关，并且每个线程在从 wait 返回后将执行相同的操作。</li>
<li>单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。</li>
</ul>
<h2 id="显式的-condition-对象">显式的 Condition 对象</h2>
<p>内置条件队列存在一些缺陷。每个内置锁都只能有一个相关联的条件队列，因而存在多个线程可能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下公开条件队列对象。</p>
<p>这些因素都使得无法满足在使用 notifyAll 时所有等待线程为同一类型的需求。</p>
<p>如果想编写一个带有多个条件谓词的并发对象，或者想获得除了条件队列可见性之外的更多控制权，就可以使用显示的 Lock 和 Condition 而不是内置锁和条件队列。</p>
<p>一个 Condition 和一个 Lock 关联在一起，就像一个条件队列和一个内置锁相关联一样。要创建一个 Condition，可以在相关联的 Lock 上调用 Lock.newCondition 方法。正如 Lock 比内置加锁提供了更为丰富的功能，Condition 同样比内置条件队列提供了更为丰富的功能：</p>
<blockquote>
<p>在每个锁上可存在多个等待、条件等待可以是可中断的或不可中断的、基于时限的等待，以及公平的或非公平的队列操作。</p>
</blockquote>
<p>与内置条件队列不同的是，对于每个 Lock ，可以有任意数量的 Condition 对象。Condition 对象继承了相关的 Lock 对象的公平性，对于公平的锁，线程会依照 FIFO 顺序从 Condition.await 中释放。</p>
<blockquote>
<p>在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是 await、signal 和 signalAll 。但是，Condition 对 Object 进行了拓展，因而它也包含 wait 和 notify 方法。一定要确保使用正确的版本 &mdash; await 和 signal 。</p>
</blockquote>
<div class="highlight"><pre style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">ConditionBoundBuffer</span>&lt;<span style="color:#268bd2">T</span>&gt; {
    
    <span style="color:#859900">protected</span> <span style="color:#859900">final</span> <span style="color:#268bd2">Lock</span> <span style="color:#268bd2">lock</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ReentrantLock</span>();
    <span style="color:#93a1a1;font-style:italic">// 条件谓词： notFull (count &lt; items.length)
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">private</span> <span style="color:#859900">final</span> <span style="color:#268bd2">Condition</span> <span style="color:#268bd2">notFull</span>= <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">newCondition</span>();
    <span style="color:#93a1a1;font-style:italic">// 条件谓词： notEmpty (count &gt; 0)
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">private</span> <span style="color:#859900">final</span> <span style="color:#268bd2">Condition</span> <span style="color:#268bd2">notEmpty</span> = <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">newCondition</span>();
    <span style="color:#859900">private</span> <span style="color:#859900">final</span> <span style="color:#268bd2">T</span>[] <span style="color:#268bd2">items</span> = (<span style="color:#268bd2">T</span>[]) <span style="color:#859900">new</span> <span style="color:#268bd2">Object</span>[<span style="color:#268bd2">10</span>];
    <span style="color:#859900">private</span> <span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">tail</span>,<span style="color:#268bd2">head</span>,<span style="color:#268bd2">count</span>;
    
    <span style="color:#93a1a1;font-style:italic">// 阻塞并直到：notFull
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">put</span>(<span style="color:#268bd2">T</span> <span style="color:#268bd2">x</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">InterruptedException</span> {
        <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">lock</span>();
        <span style="color:#859900">try</span> {
            <span style="color:#859900">while</span> (<span style="color:#268bd2">count</span> == <span style="color:#268bd2">items</span>.<span style="color:#268bd2">length</span>) {
                <span style="color:#268bd2">notFull</span>.<span style="color:#268bd2">await</span>();
            }
                <span style="color:#268bd2">items</span>[<span style="color:#268bd2">tail</span>] = <span style="color:#268bd2">x</span>;
                <span style="color:#859900">if</span> (++<span style="color:#268bd2">tail</span> == <span style="color:#268bd2">items</span>.<span style="color:#268bd2">length</span>){
                    <span style="color:#268bd2">tail</span>=<span style="color:#268bd2">0</span>;
                }
                ++<span style="color:#268bd2">count</span>;
                <span style="color:#268bd2">notEmpty</span>.<span style="color:#268bd2">signal</span>();
            
        }<span style="color:#859900">finally</span> {
            <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">unlock</span>();
        }
    }
    
    <span style="color:#93a1a1;font-style:italic">// 阻塞并直到：notEmpty
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">public</span> <span style="color:#268bd2">T</span> <span style="color:#268bd2">take</span>() <span style="color:#859900">throws</span> <span style="color:#268bd2">InterruptedException</span> {
        <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">lock</span>();
        <span style="color:#859900">try</span> {
            <span style="color:#859900">while</span> (<span style="color:#268bd2">count</span> == <span style="color:#268bd2">0</span>){
                <span style="color:#268bd2">notEmpty</span>.<span style="color:#268bd2">await</span>();
            }
            <span style="color:#268bd2">T</span> <span style="color:#268bd2">x</span> = <span style="color:#268bd2">items</span>[<span style="color:#268bd2">head</span>];
            <span style="color:#268bd2">items</span>[<span style="color:#268bd2">head</span>] = <span style="color:#859900;font-weight:bold">null</span>;
            <span style="color:#859900">if</span> (++<span style="color:#268bd2">head</span> == <span style="color:#268bd2">items</span>.<span style="color:#268bd2">length</span>){
                <span style="color:#268bd2">head</span>=<span style="color:#268bd2">0</span>;
            }
            --<span style="color:#268bd2">count</span>;
            <span style="color:#268bd2">notFull</span>.<span style="color:#268bd2">signal</span>();
            <span style="color:#859900">return</span> <span style="color:#268bd2">x</span>;
        }<span style="color:#859900">finally</span> {
            <span style="color:#268bd2">lock</span>.<span style="color:#268bd2">lock</span>();
        }
    }
}
</code></pre></div><h2 id="参考">参考</h2>
<ol>
<li>《Java 并发编程实战》</li>
<li><a href="https://www.cnblogs.com/CarpenterLee/p/7896361.html">https://www.cnblogs.com/CarpenterLee/p/7896361.html</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/54972105">https://blog.csdn.net/justloveyou_/article/details/54972105</a></li>
</ol>
        


                

                  <h4>欢迎扫码关注微信公众号：【音视频开发进阶】，获得最新文章推送~~~</h4>

                  <h4>技术问题欢迎加我微信 ezglumes ，拉你进群交流~~~</h4>
                  
                  <br/>

                  <img src="https://glumes2blog.oss-cn-shenzhen.aliyuncs.com/wexin-public.png">

                  <br/>

                


                

                


        
        
        
      </article>

      
        

<h3>相关文章</h3>
<ul style="margin-bottom: 25px;">
    
    <li><a href="https://www.glumes.com/post/android/java-proxy-design-pattern/">Java 中的静态代理和动态代理</a></li>
    
</ul>

      

      
      <ul class="pager blog-pager">
        
          <li class="previous">
            <a href="https://www.glumes.com/post/c&#43;&#43;/c&#43;&#43;-stl-container-overview/" data-toggle="tooltip" data-placement="top" title="C&#43;&#43; 标准容器库小结">&larr; Previous Post</a>
          </li>
        
        
          <li class="next">
            <a href="https://www.glumes.com/post/vulkan/vulkan-tutorial-concept/" data-toggle="tooltip" data-placement="top" title="进击的 Vulkan 移动开发（一）之今生前世">Next Post &rarr;</a>
          </li>
        
      </ul>
      

      
        
      





    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">

          
          
          
              <li>
                <a href="mailto:zhaoying9402@outlook.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
              <li>
                <a href="https://github.com/glumes" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
              <li>
                <a href="https://weibo.com/u/3157458295" title="微博">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          
        </ul>
        <p class="credits copyright text-muted">
          

          &nbsp;&bull;&nbsp;
          2020

          
            &nbsp;&bull;&nbsp;
            <a href="https://www.glumes.com/">星陨的博客</a>
            &nbsp;&bull;&nbsp;
            <a href="https://www.glumes.com/sitemap.xml">网站地图</a>
          
        </p>



       <p class="credits copyright text-muted">
            <a href="http://beian.miit.gov.cn">粤ICP备20067247号</a>
       </p>


        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.74.3</a> powered &nbsp;&bull;&nbsp; Theme by <a href="https://github.com/rootsongjc/beautifulhugo">Beautiful Hugo</a> adapted to <a href="https://github.com/glumes/glumes.com">glumes-blog</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>


<script src="https://www.glumes.com/js/jquery-1.11.2.min.js"></script>
<script src="https://www.glumes.com/js/bootstrap.min.js"></script>
<script src="https://www.glumes.com/js/main.min.js"></script>
<script src="https://www.glumes.com/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script src="https://www.glumes.com/js/prism.js?t=123"></script>





<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>







  





  </body>
</html>

