<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Glumes Blog</title>
    <link>https://glumes.github.io/tags/android/</link>
    <description>Recent content in Android on Glumes Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>zhaoying9402@gmail.com (Glumes)</managingEditor>
    <webMaster>zhaoying9402@gmail.com (Glumes)</webMaster>
    <lastBuildDate>Fri, 22 Dec 2017 16:00:05 +0800</lastBuildDate>
    
	<atom:link href="https://glumes.github.io/tags/android/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>用 Rxjava 封装 Dialog 以及 RxBinding 实现简要分析</title>
      <link>https://glumes.github.io/post/android/rxjava-wrapper-dialog/</link>
      <pubDate>Fri, 22 Dec 2017 16:00:05 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/rxjava-wrapper-dialog/</guid>
      <description>&lt;p&gt;之前有写过一篇文章：&lt;a href=&#34;http://www.glumes.com/wrapper-callback-by-rxjava/&#34;&gt;用 RxJava 封装回调方法 CallBack&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;RxJava 封装回调方法的大体思路就是：使用 Observable 的 create 方法来返回一个 Observable，在 create 方法内给事物设置回调接口，用 Observable 的 onNext 方法来接受回调接口所产生的内容。&lt;/p&gt;

&lt;p&gt;这样一来，通过 onNext 方法就把事物的回调方法转换到 Rxjava 对应的事件流里面了，再可以通过其他操作符，如 Map、FlatMap 等对事件流进行相应的转换。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 布局加载之 LayoutInflater</title>
      <link>https://glumes.github.io/post/android/android-layout-inflater/</link>
      <pubDate>Fri, 22 Dec 2017 15:55:08 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-layout-inflater/</guid>
      <description>&lt;p&gt;Activity 在界面创建时需要将 XML 布局文件中的内容加载进来，正如我们在 ListView 或者 RecyclerView 中需要将 Item 的布局加载进来一样，都是使用 LayoutInflater 来进行操作的。&lt;/p&gt;

&lt;p&gt;LayoutInflater 实例的获取有多种方式，但最终是通过&lt;code&gt;(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)&lt;/code&gt;来得到的，也就是说加载布局的 &lt;code&gt;LayoutInflater&lt;/code&gt; 是来自于系统服务的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 插件换肤原理及源码分析</title>
      <link>https://glumes.github.io/post/android/android-change-skin-by-plugin/</link>
      <pubDate>Fri, 22 Dec 2017 15:51:44 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-change-skin-by-plugin/</guid>
      <description>&lt;p&gt;在学习安卓插件化开发的路上，有一处风景是肯定要观赏的，那就是基于插件的应用换肤了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Service 启动过程源码分析（一）</title>
      <link>https://glumes.github.io/post/android/android-start-service/</link>
      <pubDate>Fri, 22 Dec 2017 15:40:19 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-start-service/</guid>
      <description>&lt;p&gt;Service 组件也是 Android 四大组件之一，它的启动过程分为显示和隐式两种。对于隐式启动的 Service 组件来说，我们只需要它的组件名称；对于显示启动的 Service 组件来说，我们需要知道它的类名称。&lt;/p&gt;

&lt;p&gt;Service 组件可以被 Activity 组件启动，也可以被其他的 Service 组件启动。同时，它既可以在启动它的 Activity 组件或者 Service 组件所在的应用程序中启动，也可以在一个新的应用程序进程中启动。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android StateMachine 状态机分析</title>
      <link>https://glumes.github.io/post/android/android-statemachine/</link>
      <pubDate>Fri, 22 Dec 2017 15:37:04 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-statemachine/</guid>
      <description>&lt;p&gt;之前就有写过一篇文章来学习状态机：&lt;a href=&#34;http://www.glumes.com/statemachine_learn/&#34;&gt;状态机学习&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在之后的工作中多次用到了 StateMachine 状态机，简单记录其原理。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android LruCache实现分析</title>
      <link>https://glumes.github.io/post/android/android-lrucache/</link>
      <pubDate>Fri, 22 Dec 2017 15:35:23 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-lrucache/</guid>
      <description>&lt;p&gt;LruCache 是安卓开发中常用到的缓存技术，LRU 的全名是 Least Recently Used，表示最近最少使用算法，也就是说当内存快到达阈值时，若某个对象最近很少使用的，那么它就会被回收掉以释放内存。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Activity 创建 Window 及添加 View 流程分析</title>
      <link>https://glumes.github.io/post/android/android-window-and-view/</link>
      <pubDate>Fri, 22 Dec 2017 15:33:22 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-window-and-view/</guid>
      <description>&lt;p&gt;在之前有分析过 Android 6.0 Launcher 启动 Activity 过程，文章的链接如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-1/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-2/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-3/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-4/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（四）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 系统服务启动 SystemServer</title>
      <link>https://glumes.github.io/post/android/android-system-server/</link>
      <pubDate>Fri, 22 Dec 2017 15:30:26 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-system-server/</guid>
      <description>&lt;p&gt;在之前 &lt;a href=&#34;http://www.glumes.com/android-servicemanager/&#34;&gt;Android 系统服务管理 ServiceManager&lt;/a&gt; 中学习了各种系统服务 Service 都是通过 &lt;code&gt;ServiceManager&lt;/code&gt; 来管理的，从 ServiceManager 中来获得系统服务的 Binder 对象引用。这内容涉及到了 &lt;code&gt;ContextImpl&lt;/code&gt; 类、&lt;code&gt;SystemServiceRegistry&lt;/code&gt; 类、&lt;code&gt;ServiceManager&lt;/code&gt; 类、&lt;code&gt;ServiceManagerNative&lt;/code&gt; 类等等。&lt;/p&gt;

&lt;p&gt;那么问题就来了，ServiceManager 所管理的那些 Service 的 Binder 对象引用又是何时注册添加的呢？&lt;/p&gt;

&lt;p&gt;事实上这些服务 Service 是 SystemServer 进程中启动的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 系统服务管理 ServiceManager</title>
      <link>https://glumes.github.io/post/android/android-service-manager/</link>
      <pubDate>Fri, 22 Dec 2017 15:27:11 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-service-manager/</guid>
      <description>&lt;p&gt;在应用程序编程时，经常使用到 getSystemService(String serviceName) 方法来获得一个系统服务，它的实现也是在 ContextImpl 中的，根据不同的参数返回不同的系统服务，这些系统服务都是由 ServiceManager 管理的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Material Desing 控件小结-2</title>
      <link>https://glumes.github.io/post/android/android-material-design-summary-2/</link>
      <pubDate>Fri, 22 Dec 2017 15:22:15 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-material-design-summary-2/</guid>
      <description>&lt;p&gt;总结一下 Material Design 控件使用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Material Desing 控件小结-1</title>
      <link>https://glumes.github.io/post/android/android-material-design-summary-1/</link>
      <pubDate>Fri, 22 Dec 2017 15:19:03 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-material-design-summary-1/</guid>
      <description>&lt;p&gt;总结一下 Material Design 控件使用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Binder Summary</title>
      <link>https://glumes.github.io/post/android/android-binder-summary/</link>
      <pubDate>Fri, 22 Dec 2017 10:50:43 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-binder-summary/</guid>
      <description>&lt;p&gt;Binder 是什么？在英文中 Binder 是 粘合剂 的意思，表示将两样东西粘在一起。而在 Android 开发中，Binder 的意思多了去了。不同的角度有着不同的解释。&lt;/p&gt;

&lt;p&gt;它既可以是 Android 中实现了 IBinder 接口的一个单纯的类，也可以是 Android 中进程跨进程通信（IPC）的一种方式，还可以看作是工作在内核态的 Linux 驱动 &lt;code&gt;/dev/binder&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dagger2 在 Android 中的使用</title>
      <link>https://glumes.github.io/post/android/android-dagger-use/</link>
      <pubDate>Fri, 22 Dec 2017 10:47:52 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-dagger-use/</guid>
      <description>&lt;p&gt;Dagger2 是一个进行依赖注入的框架，早先是由 Square 公司写的，后来由 Google 来维护了，能由 Google 亲自维护的东西，肯定值得学习。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title> Android 6.0 Launcher 启动 Activity 过程分析小结（四）</title>
      <link>https://glumes.github.io/post/android/android-start-activity-from-launcher-4/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:49 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-start-activity-from-launcher-4/</guid>
      <description>&lt;p&gt;在如下三篇文章中过了一遍 Launcher 启动 Activity 的代码流程。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;start-activity-from-launcher-in-android-1&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;start-activity-from-launcher-in-android-2&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;start-activity-from-launcher-in-android-3&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（三）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而， 即使看过了多遍代码流程依旧有点云里雾里的感觉。不从整体上来把握，光抓住细节代码会始终不得要领。&lt;/p&gt;

&lt;p&gt;由于是从 Launcher 组件启动一个 Activity 组件，其中还需要与 ActivityManagerService 通信，而这三个部分都是位于不同的进程内，涉及进程间通信，因此可以将整个过程划分为三个不同的部分来分析，在 Launcher 进程内的操作，在 ActivityManagerService 进程内的操作，在创建的应用程序进程内的操作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Launcher 启动 Activity 过程源码分析（三）</title>
      <link>https://glumes.github.io/post/android/android-start-activity-from-launcher-3/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:45 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-start-activity-from-launcher-3/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-2/&#34;&gt; Android 6.0 Launcher 启动 Activity 过程源码分析（二）&lt;/a&gt; 分析完了对待启动 Activity 组件的验证过程，获得组件信息，以及 ActivityRecord 添加至栈顶，将其他 Activity 进入中止状态，最后将待启动的 Activity 组件进入 &lt;code&gt;Resumed&lt;/code&gt;状态，然而，由于待启动的 Activity 组件的应用程序进程尚未启动，最后执行 &lt;code&gt;startSpecificActivityLocked&lt;/code&gt;方法创建进程。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Launcher 启动 Activity 过程源码分析（二）</title>
      <link>https://glumes.github.io/post/android/android-start-activity-from-launcher-2/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:42 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-start-activity-from-launcher-2/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;http://www.glumes.com/start-activity-from-launcher-in-android-1/&#34;&gt;Android 6.0 Launcher 启动 Activity 过程源码分析（一）&lt;/a&gt; 分析完了 Launcher 组件中启动的步骤，接下来的环节是该 ActivityManagerService 出场了。&lt;/p&gt;

&lt;p&gt;通过 ActivityManagerNative.getDefault() 方法得到 ActivityManagerService 的代理对象后执行的 startActivity 方法，最终会发起进程间通信请求，通过 Binder 驱动，再调用 ActivityManagerService 中对应的方法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 6.0 Launcher 启动 Activity 过程源码分析（一）</title>
      <link>https://glumes.github.io/post/android/android-start-activity-from-launcher-1/</link>
      <pubDate>Fri, 22 Dec 2017 10:40:38 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-start-activity-from-launcher-1/</guid>
      <description>&lt;p&gt;当 Android 系统在启动时，会扫描系统特定目录，然后自动安装里面的 Android 应用程序。当系统启动完成之后，会启动一个 Home 应用程序来显示安装在系统中的 Android 应用程序。&lt;/p&gt;

&lt;p&gt;这个应用程序就是 Launcher 应用，也就是手机屏幕上显示的各种应用图标，Launcher 是 Android 系统启动的第一个应用程序。&lt;/p&gt;

&lt;p&gt;而当我们点击应用程序图标时，也就开启了从 Launcher 启动 Activity 的过程。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 RxJava 封装回调方法 CallBack</title>
      <link>https://glumes.github.io/post/android/rxjava-wrapper-callback/</link>
      <pubDate>Fri, 22 Dec 2017 10:38:34 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/rxjava-wrapper-callback/</guid>
      <description>&lt;p&gt;在知乎上看到这样一个问题：&lt;a href=&#34;https://www.zhihu.com/question/39492234&#34;&gt;RxJava正确的封装callback的方式应该是怎么样的？&lt;/a&gt;。虽说已经是个一年前的问题了，自己现在才遇到 (羞愧脸) 。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 硬件抽象层调用流程小结</title>
      <link>https://glumes.github.io/post/android/android-hal-summary/</link>
      <pubDate>Fri, 22 Dec 2017 10:31:13 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/android-hal-summary/</guid>
      <description>&lt;p&gt;Android 从 5.0 开始使用新的相机 API Camera2 来代替之前的旧版本，从而支持更多的特性。&lt;/p&gt;

&lt;p&gt;在学习新的 API 调用之外，也还是要了解一下 Android 底层发生了哪些变化，从而能够让我们对 API 的调用流程更加的清晰，知其所以然。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin 函数式编程与 Anko 构建布局实现原理分析</title>
      <link>https://glumes.github.io/post/android/kotlin-functional-programming-whth-anko/</link>
      <pubDate>Fri, 22 Dec 2017 10:26:57 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/kotlin-functional-programming-whth-anko/</guid>
      <description>&lt;p&gt;之前讲到了如何在 &lt;a href=&#34;http://www.glumes.com/kotlin-anko-usage/&#34;&gt;Kotlin 开发中使用 Anko 构建布局&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这一篇将是分析其原理。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin 使用 Anko 布局那些事</title>
      <link>https://glumes.github.io/post/android/kotlin-with-anko/</link>
      <pubDate>Fri, 22 Dec 2017 10:21:26 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.github.io/post/android/kotlin-with-anko/</guid>
      <description>&lt;p&gt;学习 Kotlin 应该都或多或少听过 Anko 这个开源库。&lt;/p&gt;

&lt;p&gt;使用 Anko 来构建界面会更加简单、快捷。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>