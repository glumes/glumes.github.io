<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JNI on Glumes Blog</title>
    <link>https://glumes.com/tags/jni/</link>
    <description>Recent content in JNI on Glumes Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>zhaoying9402@gmail.com (Glumes)</managingEditor>
    <webMaster>zhaoying9402@gmail.com (Glumes)</webMaster>
    <lastBuildDate>Wed, 25 Jul 2018 13:36:50 +0800</lastBuildDate>
    
	<atom:link href="https://glumes.com/tags/jni/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android JNI 之 Bitmap 操作</title>
      <link>https://glumes.com/post/android/android-jni-bitmap-operation/</link>
      <pubDate>Wed, 25 Jul 2018 13:36:50 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-bitmap-operation/</guid>
      <description>&lt;p&gt;在 Android 中通过 JNI 去操作 Bitmap。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 中的线程操作</title>
      <link>https://glumes.com/post/android/android-jni-thread-operation/</link>
      <pubDate>Sun, 15 Jul 2018 14:12:25 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-thread-operation/</guid>
      <description>&lt;p&gt;学习一下如何在 Native 代码中使用线程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 调用时的异常处理</title>
      <link>https://glumes.com/post/android/android-jni-exception-handle/</link>
      <pubDate>Wed, 16 May 2018 17:55:52 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-exception-handle/</guid>
      <description>&lt;p&gt;Android JNI 调用时的异常主要有如下两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Native 代码调用 Java 层代码时发生了异常要处理&lt;/li&gt;
&lt;li&gt;Native 代码自己抛出了一个异常让 Java 层去处理&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 中的引用管理</title>
      <link>https://glumes.com/post/android/android-jni-reference-manage-rules/</link>
      <pubDate>Wed, 16 May 2018 17:50:06 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-reference-manage-rules/</guid>
      <description>&lt;p&gt;在 Native 代码中有时候会接收 Java 传入的引用类型参数，有时候也会通过 NewObject 方法来创建一个 Java 的引用类型变量。&lt;/p&gt;

&lt;p&gt;在编写 Native 代码时，要注意这个代表 Java 数据结构类型的引用在使用时会被 GC 回收的可能性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android  JNI 调用时缓存字段和方法 ID</title>
      <link>https://glumes.com/post/android/android-jni-cache-fieldid-and-methodid/</link>
      <pubDate>Mon, 07 May 2018 10:39:50 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-cache-fieldid-and-methodid/</guid>
      <description>&lt;p&gt;在 JNI 去调用 Java 的方法和访问字段时，最先要做的操作就是获得对应的类以及对应的方法 id。&lt;/p&gt;

&lt;p&gt;事实上，通过 FindClass 、GetFieldID、GetMethodID 去找到对应的信息是很耗时的，如果方法被频繁调用，那么肯定不能每次都去查找对应的信息，有必要将它们缓存起来，在下一次调用时，直接使用缓存内容就好了。&lt;/p&gt;

&lt;p&gt;缓存有两种方式，分别是使用时缓存和初始化时缓存。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 通过 JNI 调用 Java 类的构造方法和父类的方法</title>
      <link>https://glumes.com/post/android/android-jni-invoke-constructor-method-and-super-method/</link>
      <pubDate>Mon, 07 May 2018 10:32:01 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-invoke-constructor-method-and-super-method/</guid>
      <description>&lt;p&gt;Android 还可以通过 JNI 来调用 Java 一个类的构造方法，从而创建一个 Java 类。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 通过 JNI 访问 Java 字段和方法调用</title>
      <link>https://glumes.com/post/android/android-jni-access-field-and-method/</link>
      <pubDate>Mon, 07 May 2018 10:27:08 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-access-field-and-method/</guid>
      <description>&lt;p&gt;在前面的两篇文章中，介绍了 Android 通过 JNI 进行基础类型、字符串和数组的相关操作，并描述了 Java 和 Native 在类型和签名之间的转换关系。&lt;/p&gt;

&lt;p&gt;有了之前那些基础，就可以实现 Java 和 Native 的相互调用了，在 Native 中去访问 Java 类的字段并调用相应的方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 数组 操作</title>
      <link>https://glumes.com/post/android/android-jni-array-operation/</link>
      <pubDate>Mon, 07 May 2018 10:21:22 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-array-operation/</guid>
      <description>&lt;p&gt;JNI 中有两种数组操作，基础数据类型数组和对象数组，JNI 对待基础数据类型数组和对象数组是不一样的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android JNI 基本操作 </title>
      <link>https://glumes.com/post/android/android-jni-basic-operation/</link>
      <pubDate>Mon, 07 May 2018 09:44:57 +0800</pubDate>
      <author>zhaoying9402@gmail.com (Glumes)</author>
      <guid>https://glumes.com/post/android/android-jni-basic-operation/</guid>
      <description>&lt;p&gt;自从 Android Studio 升级到 2.3 版本以后，使用 CMake 进行编译就方便多了，不需要再写 Android.mk 了，也不需要用 javah 来生成头文件了，直接写好 native 方法，快捷方式就可以生成对应的 C++ 方法，只要专注写好 C++ 代码，CMake 就可以指定的 CPU 架构生成对应的 SO 库。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>